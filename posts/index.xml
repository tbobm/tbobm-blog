<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on tbobm.dev</title>
    <link>https://blog.tbobm.dev/posts/</link>
    <description>Recent content in Posts on tbobm.dev</description>
    <image>
      <title>tbobm.dev</title>
      <url>https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.133.0</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Apr 2025 21:30:00 +0200</lastBuildDate>
    <atom:link href="https://blog.tbobm.dev/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bootstrapping SQL databases for local and production setup</title>
      <link>https://blog.tbobm.dev/posts/db-bootstrapping/</link>
      <pubDate>Fri, 18 Apr 2025 21:30:00 +0200</pubDate>
      <guid>https://blog.tbobm.dev/posts/db-bootstrapping/</guid>
      <description>A practical walkthrough of how I manage SQL databases across dev and prod - from local Docker setups to CI/CD-powered migrations in the cloud.
Intro When working with databases, it’s easy to fall into the trap of taking shortcuts — a quick container here, a few clicks in the AWS console there, and before you know it, you&amp;rsquo;re running production off an unversioned schema with the master user.
This article is a hands-on guide—and a collection of things I’ve grown to enjoy when working with SQL databases in modern environments.</description>
    </item>
    <item>
      <title>Complete health checks and why they matter</title>
      <link>https://blog.tbobm.dev/posts/complete-health-checks/</link>
      <pubDate>Tue, 11 Mar 2025 11:30:20 +0200</pubDate>
      <guid>https://blog.tbobm.dev/posts/complete-health-checks/</guid>
      <description>Standard health checks tell you if an app is running but not if it’s actually working. Complete Health Checks go deeper, verifying dependencies like databases and caches to catch issues early and keep deployments smooth.
In this article, we’ll cover why they matter, how to set them up, and the key differences between liveness and readiness checks—so your services stay reliable and efficient in production.
What are health checks and why are they so useful Having an application that performs some kind of processing is only the first part of the journey.</description>
    </item>
    <item>
      <title>Watermarking pictures (fast) using Pillow and Libvips</title>
      <link>https://blog.tbobm.dev/posts/watermarking-pictures-fast/</link>
      <pubDate>Wed, 13 Nov 2024 13:35:00 +0200</pubDate>
      <guid>https://blog.tbobm.dev/posts/watermarking-pictures-fast/</guid>
      <description>Working in the media processing industry, I very often encounter 2 concepts: adding overlay to images and doing it fast.
As I&amp;rsquo;m very much interested in tackling this problem well enough and using proper tooling for performance efficiency, I explored several options that allow watermarking pictures.
Code is available at github.com/tbobm/watermarking-images-for-fun-and-profit
Watermarking pictures To put things back in context, watermarking is the act of applying an overlay to a media. This can be performed through many different operation and is used to apply branding, establish ownership, or limit usage to a specific audience 1.</description>
    </item>
    <item>
      <title>Tracking Row Level changes in PostgreSQL</title>
      <link>https://blog.tbobm.dev/posts/row-level-database-tracking/</link>
      <pubDate>Mon, 04 Nov 2024 17:17:00 +0200</pubDate>
      <guid>https://blog.tbobm.dev/posts/row-level-database-tracking/</guid>
      <description>Ownerships and modification dates often have a huge role in troubleshooting or understanding how applications work. Making last change metadata available can be a game changer in case of bug hunting or to understand how data behaves without digging through logs for hours.
Let&amp;rsquo;s dive in a way of automating this &amp;ldquo;last update&amp;rdquo; tracking at the row level in Postgresql.
Code is available at github.com/tbobm/postgresql-row-level-changes
Automatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system.</description>
    </item>
  </channel>
</rss>
