<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Complete health checks and why they matter | tbobm.dev</title><meta name=keywords content="tech,reliability,optimization"><meta name=description content="Standard health checks tell you if an app is running but not if it’s actually working. Complete Health Checks go deeper, verifying dependencies like databases and caches to catch issues early and keep deployments smooth.
In this article, we’ll cover why they matter, how to set them up, and the key differences between liveness and readiness checks—so your services stay reliable and efficient in production.
What are health checks and why are they so useful Having an application that performs some kind of processing is only the first part of the journey."><meta name=author content="Theo &#34;Bob&#34; Massard"><link rel=canonical href=https://blog.tbobm.dev/posts/complete-health-checks/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.tbobm.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.tbobm.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.tbobm.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.tbobm.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.tbobm.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-TH8WFGGJBS"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TH8WFGGJBS",{anonymize_ip:!1})}</script><meta property="og:title" content="Complete health checks and why they matter"><meta property="og:description" content="Standard health checks tell you if an app is running but not if it’s actually working. Complete Health Checks go deeper, verifying dependencies like databases and caches to catch issues early and keep deployments smooth.
In this article, we’ll cover why they matter, how to set them up, and the key differences between liveness and readiness checks—so your services stay reliable and efficient in production.
What are health checks and why are they so useful Having an application that performs some kind of processing is only the first part of the journey."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.tbobm.dev/posts/complete-health-checks/"><meta property="og:image" content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-11T11:30:20+02:00"><meta property="article:modified_time" content="2025-03-11T11:30:20+02:00"><meta property="og:site_name" content="tbobm.dev"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Complete health checks and why they matter"><meta name=twitter:description content="Standard health checks tell you if an app is running but not if it’s actually working. Complete Health Checks go deeper, verifying dependencies like databases and caches to catch issues early and keep deployments smooth.
In this article, we’ll cover why they matter, how to set them up, and the key differences between liveness and readiness checks—so your services stay reliable and efficient in production.
What are health checks and why are they so useful Having an application that performs some kind of processing is only the first part of the journey."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.tbobm.dev/posts/"},{"@type":"ListItem","position":2,"name":"Complete health checks and why they matter","item":"https://blog.tbobm.dev/posts/complete-health-checks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Complete health checks and why they matter","name":"Complete health checks and why they matter","description":"Standard health checks tell you if an app is running but not if it’s actually working. Complete Health Checks go deeper, verifying dependencies like databases and caches to catch issues early and keep deployments smooth.\nIn this article, we’ll cover why they matter, how to set them up, and the key differences between liveness and readiness checks—so your services stay reliable and efficient in production.\nWhat are health checks and why are they so useful Having an application that performs some kind of processing is only the first part of the journey.","keywords":["tech","reliability","optimization"],"articleBody":"Standard health checks tell you if an app is running but not if it’s actually working. Complete Health Checks go deeper, verifying dependencies like databases and caches to catch issues early and keep deployments smooth.\nIn this article, we’ll cover why they matter, how to set them up, and the key differences between liveness and readiness checks—so your services stay reliable and efficient in production.\nWhat are health checks and why are they so useful Having an application that performs some kind of processing is only the first part of the journey. Once in production, it’s quite impossible to fly blind and just hope that everything works. To address this need, we can introduce a utility feature that exposes the status of our application using a health check.\nAt first, we can setup a health check like the one we often see in most APIs: /health.\nThe /health route is expected to answer a 2XX status code and translates into the API saying:\nI’m alive and able to receive HTTP requests!\nUsing a mock API, we can try this route using curl:\n$ curl http://localhost/health {\"message\": \"alive!\"} We usually set those in many shape or forms but we’ll stick to Python to match our example:\n1 2 3 @app.route(\"/health\") def health_check(): return {\"message\": \"alive!\"} However, being able to to receive HTTP requests is one thing, processing them successfully is another, more advanced topic.\nI already wrote about this in my article on Black-box monitoring (see Black-box monitoring at Diffusely using k6), there are plenty of ways to prevent our API clients from being the first entities that will discover that something is wrong in our applications.\nEver discovered upon testing a new deployment that the DATABASE_URL wasn’t properly set ?\nComplete Health Checks might be just the right thing!\nIntroducing: “Complete” health checks The goal of the Complete Health Check pattern is to expose the status of 3rd party dependencies 1. This would mean that observers and coordinators like monitoring or orchestration services. They aim to be an additional source of information that target deployments of new versions of an app.\nNot to be a replacement of standard availability health checks as they answer different question. Distributed systems where east-west traffic happen a lot are most suited for this as failure to answer perfectly, at scale, could impact the overall performances of the system.\nExpected benefits Complete Health Checks go beyond the simple HTTP 200 response by actively verifying the availability and functionality of key system dependencies. This deeper validation provides several advantages, especially in environments where reliability and efficiency are critical.\nIn a microservice based architecture, they help preventing cascading outages and keep the retry capabilities for more complex situations.\nIntegrate the Fail-Fast Concept in Deployments By proactively detecting failures before they impact users, Complete Health Checks help implement the fail-fast principle in new deployments. If a crucial dependency is unreachable, the deployment can be cancelled and rolled back immediately, reducing the risk of degraded service.\nDatabase Connectivity Issues: If an application can not connect to its database, it must fail as early as possible instead of attempting to serve requests that will fail anyway. External Service Availability: Some applications rely on third-party APIs or internal services. A proper health check should validate access to these endpoints to ensure smooth operation. Guarantee Processing Efficiency During Deployments A system that is aware of its own health can make smarter decisions about request handling. Instead of blindly accepting traffic, it can gracefully reject requests 2 if a key component is unavailable.\nServe Only Valid Requests: If the application detects missing dependencies, it can return an appropriate error status instead of inefficiently processing doomed requests. Optimize Resource Utilization: Prevent wasted resources in production by ensuring that only healthy instances handle user traffic. This goes a long way towards green IT and cost reduction for processing heavy requests. Expose More Than Just Basic Availability Basic health checks only confirm whether an application is running, but Complete Health Checks provide deeper insights into system health.\nInstant Cache Status Visibility: A well-implemented health check can report if cache layers (e.g., Redis, Memcached) are operational, helping diagnose performance bottlenecks. Granular System Insights: Instead of a binary “up or down” status, a more granular health check endpoint can return structured data about application health, making it easier to debug issues before they escalate. How to set them up As a proper, hands-on example, let’s consider the following application:\nSmall API using FastAPI Caching using Redis Backend database storage using postgresql It translates into the following diagram:\nHere, the API will use the cache to reduce the stress on our database and third party calls.\nTo properly implement a Complete Health Check, we need to ensure that we can reach both our Redis and our PostgreSQL dependencies.\nRedis: performing a ping command. PostgreSQL: executing a SELECT 1; statement against our database. 1 2 3 4 5 6 7 8 9 10 def perform_full_healthcheck() -\u003e bool: # ensure redis can be reached redis_client.ping() # ensure postgres can be reached and we have read permission with psycopg2.connect(DB_URL) as conn: with conn.cursor() as cur: cur.execute(\"SELECT 1;\") cur.fetchone() return True We can proceed to include our complete health check as another route in our application:\n1 2 3 4 5 6 7 8 @app.route(\"/health-full\") def perform_health_check(): try: complete_check_successful = perform_full_healthcheck() return {\"message\": \"full health check works!\"} except Exception as err: # something went wrong # we have to return any non-2XX status code return {\"message\": \"full health check does not work\"}, 500 Most of the services only support a single strategy for health checks, meaning that for a given “health check” initiator (i.e.: AWS Application Load Balancer), which means that:\nwe don’t want to spam our database or cache instance once the “full setup” is done, we can switch to the default “serve requests” check This can be implemented using the following pattern:\n1 2 3 4 5 6 7 8 @app.route(\"/health\") def perform_health_check(): if full_health_check_performed: return {\"message\": \"simple health check works!\"} complete_check_successful = perform_full_healthcheck() if complete_check_successful: full_health_check_performed = True return {\"message\": \"full health check works!\"} In the above snippet, we assume that we use global variables to simplify switching between readiness and healthiness when using the same endpoint.\nIdeally we use 2 distinct endpoints but some orchestration services only allow a single endpoint to be tested for healthiness.\nLiveness vs readinesss Health checks in modern cloud environments typically fall into two categories: liveness checks and readiness checks. Understanding the distinction is crucial when designing a robust health check strategy.\nLiveness Checks: Ensuring the Application is Running\nA liveness check determines whether the application process is alive and capable of serving requests. This is what most standard health checks do—they simply confirm that the service is reachable and responding to HTTP requests.\nUsed by load balancers, orchestrators (ECS, Kubernetes), and service meshes to determine whether a container should continue running. If a liveness check fails, the container is typically restarted. Examples: Responding with an HTTP 200 status from a /health endpoint. Checking if the process is still running using a command like pgrep my-service. Readiness Checks: Ensuring the Application is Ready to Handle Traffic\nA readiness check is a more advanced health check that verifies whether the application is fully initialized and ready to serve traffic. It does not just check if the process is running but also ensures all dependencies (database, cache, external APIs) are in a good state.\nUsed by load balancers, Kubernetes probes, and container orchestrators to determine when an instance should start receiving traffic. Unlike liveness checks, failing a readiness check does not trigger a restart—it simply removes the instance from the traffic pool. Examples: Checking if the database connection is live before marking the service as ready. Validating access to an external API or cache system. Complete Health Check: A Readiness Check for Real-World Deployments\nA Complete Health Check is effectively a readiness check that goes beyond simple “reachability” checks. Instead of just verifying if the application is running, it ensures the service is in a state where it can properly handle requests.\nBest used for validating configurations and dependencies before accepting traffic. Can be implemented at the container image level using an entry point script or a dedicated health check. Ensures that misconfigured or partially initialized instances do not serve traffic. Implementation Examples (ECS, Kubernetes)\nComplete Health Checks can be integrated into common cloud environments like ECS and Kubernetes.\nHere we consider the /health route to return the standard health check and the /health-full acts as the complete health check.\nKubernetes:\nlivenessProbe: httpGet: path: /health port: 8080 initialDelaySeconds: 3 periodSeconds: 10 readinessProbe: httpGet: path: /health-full port: 8080 initialDelaySeconds: 10 periodSeconds: 5 The liveness probe ensures the container is running. The readiness probe ensures the container is ready before accepting traffic. Check the corresponding Kubernetes documentation on Liveness, Readiness (and Startup) probes.\nAWS ECS (Fargate/EC2-backed tasks):\n\"healthCheck\": { \"command\": [ \"CMD-SHELL\", \"curl -f http://localhost:8080/health-full || exit 1\" ], \"interval\": 30, \"timeout\": 5, \"retries\": 3, \"startPeriod\": 10 } The ECS task only joins the service once it passes the readiness check. A failing readiness check removes the task from the load balancer without restarting it. Feel free to check the dedicated documentation for a deeper understanding of how health checks work in ECS.\nCombining Multiple Health Check Sources:\nComplete Health Checks provide more granular health insights, making them valuable for multiple system components:\nLoad Balancer (ALB, NLB, API Gateway): Uses health checks to determine if an instance should receive traffic. Container Orchestrator (Kubernetes, ECS): Uses readiness probes to decide when an instance is ready for service. ECS Task-Level Health Check: Ensures that only fully configured instances join the service. By leveraging both liveness and readiness checks correctly, applications can achieve higher availability, prevent misconfigured deployments, and optimize request handling.\nConclusion Implementing both liveness and readiness checks ensures that your application remains not just available, but fully operational and efficient. This approach helps catch misconfigurations early, optimizes resource usage, and prevents unnecessary downtime.\nNo matter the deployment platform Kubernetes, ECS or anything that supports health checks integrating these checks strengthens reliability and predictability.\nWant to see a minimal implementation? Check it out here: complete-health-checks-design\nFeel free to reach out if you have feedbacks or questions !\nTheo “Bob” Massard\nIn regard to our application’s code, here we consider 3rd party application anything that we interact with and that we would want to test, such as Databases, Message Brokers, …. ↩︎\nThis can be handled at the service mesh level if any ↩︎\n","wordCount":"1751","inLanguage":"en","image":"https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-03-11T11:30:20+02:00","dateModified":"2025-03-11T11:30:20+02:00","author":{"@type":"Person","name":"Theo \"Bob\" Massard"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tbobm.dev/posts/complete-health-checks/"},"publisher":{"@type":"Organization","name":"tbobm.dev","logo":{"@type":"ImageObject","url":"https://blog.tbobm.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.tbobm.dev accesskey=h title="tbobm.dev (Alt + H)">tbobm.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.tbobm.dev/about/ title=about><span>about</span></a></li><li><a href=https://blog.tbobm.dev/now/ title=now><span>now</span></a></li><li><a href=https://blog.tbobm.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.tbobm.dev>Home</a>&nbsp;»&nbsp;<a href=https://blog.tbobm.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Complete health checks and why they matter</h1><div class=post-meta><span title='2025-03-11 11:30:20 +0200 +0200'>March 11, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1751 words&nbsp;·&nbsp;Theo "Bob" Massard&nbsp;|&nbsp;<a href=https://github.com/tbobm/tbobm-blog/content/posts/complete-health-checks/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introducing-complete-healthchecks>Introducing: &ldquo;Complete&rdquo; health checks </a></li><li><a href=#expected-benefits>Expected benefits</a><ul><li><a href=#integrate-the-fail-fast-concept-in-deployments>Integrate the Fail-Fast Concept in Deployments</a></li><li><a href=#guarantee-processing-efficiency-during-deployments>Guarantee Processing Efficiency During Deployments</a></li><li><a href=#expose-more-than-just-basic-availability>Expose More Than Just Basic Availability</a></li></ul></li><li><a href=#how-to-set-them-up>How to set them up</a></li><li><a href=#liveness-vs-readinesss>Liveness vs readinesss</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>Standard health checks tell you if an app is running but not if it’s actually working.
<strong>Complete Health Checks</strong> go deeper, verifying dependencies like databases and caches to catch issues early and keep deployments smooth.</p><p>In this article, we’ll cover why they matter, how to set them up,
and the key differences between liveness and readiness checks—so your services stay reliable and efficient in production.</p><h1 id=what-are-health-checks-and-why-are-they-souseful>What are health checks and why are they so useful<a hidden class=anchor aria-hidden=true href=#what-are-health-checks-and-why-are-they-souseful>#</a></h1><p>Having an application that performs some kind of processing is only the first part of the journey.
Once in production, it&rsquo;s quite impossible to <em>fly blind</em> and just hope that everything works.
To address this need, we can introduce a utility feature that exposes the status of our application using a health check.</p><p>At first, we can setup a health check like the one we often see in most APIs: <code>/health</code>.</p><p>The <code>/health</code> route is expected to answer a 2XX status code and translates into the API saying:</p><blockquote><p>I&rsquo;m <strong>alive</strong> and able to receive HTTP requests!</p></blockquote><p>Using a mock API, we can try this route using <a href=https://curl.se><code>curl</code></a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash-session data-lang=bash-session><span class=line><span class=cl><span class=gp>$</span> curl http://localhost/health
</span></span><span class=line><span class=cl><span class=go>{&#34;message&#34;: &#34;alive!&#34;}
</span></span></span></code></pre></div><p>We usually set those in many shape or forms but we&rsquo;ll stick to Python to match
our example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s2>&#34;/health&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>health_check</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;alive!&#34;</span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>However, being able to to receive HTTP requests is one thing, processing them successfully is another,
more advanced topic.</p><p>I already wrote about this in my article on Black-box monitoring (see <a href=https://medium.diffuse.ly/black-box-monitoring-at-meero-using-k6-50ff79800cbc>Black-box monitoring at Diffusely using k6</a>), there are plenty of ways to prevent our API clients from
being the first entities that will discover that something is wrong in our applications.</p><p>Ever discovered upon testing a new deployment that the <code>DATABASE_URL</code> wasn&rsquo;t properly set ?</p><p><strong>Complete Health Checks</strong> might be just the right thing!</p><h2 id=introducing-complete-healthchecks>Introducing: &ldquo;Complete&rdquo; health checks <a hidden class=anchor aria-hidden=true href=#introducing-complete-healthchecks>#</a></h2><p>The goal of the Complete Health Check pattern is to expose the status
of <em>3rd party dependencies</em> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. This would mean that observers and coordinators
like monitoring or orchestration services.
They aim to be an <strong>additional source of information</strong> that target deployments of new versions of an app.</p><p>Not to be a replacement of standard availability health checks as they answer different question.
Distributed systems where <a href=https://en.wikipedia.org/wiki/East-west_traffic>east-west traffic</a> happen a lot are most suited for this
as failure to answer perfectly, at scale, could impact the overall performances of the system.</p><h2 id=expected-benefits>Expected benefits<a hidden class=anchor aria-hidden=true href=#expected-benefits>#</a></h2><p>Complete Health Checks go beyond the simple <a href=https://http.cat/status/200>HTTP 200</a> response by actively verifying the availability
and functionality of key system dependencies. This deeper validation provides several advantages,
especially in environments where reliability and efficiency are critical.</p><p>In a microservice based architecture, they help preventing cascading outages and keep
the retry capabilities for more complex situations.</p><h3 id=integrate-the-fail-fast-concept-in-deployments>Integrate the Fail-Fast Concept in Deployments<a hidden class=anchor aria-hidden=true href=#integrate-the-fail-fast-concept-in-deployments>#</a></h3><p>By proactively detecting failures before they impact users, Complete Health Checks help
implement the <a href=https://en.wikipedia.org/wiki/Fail-fast_system#Hardware_and_software>fail-fast principle</a> in new deployments. If a crucial dependency is
unreachable, the deployment can be cancelled and rolled back immediately, reducing the risk of degraded service.</p><ul><li><strong>Database Connectivity Issues</strong>: If an application can not connect to its database, it must fail
as early as possible instead of attempting to serve requests that will fail anyway.</li><li><strong>External Service Availability</strong>: Some applications rely on third-party APIs or internal services.
A proper health check should validate access to these endpoints to ensure smooth operation.</li></ul><h3 id=guarantee-processing-efficiency-during-deployments>Guarantee Processing Efficiency During Deployments<a hidden class=anchor aria-hidden=true href=#guarantee-processing-efficiency-during-deployments>#</a></h3><p>A system that is aware of its own health can make smarter decisions about request handling.
Instead of blindly accepting traffic,
it can gracefully reject requests <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> if a key component is unavailable.</p><ul><li><strong>Serve Only Valid Requests</strong>: If the application detects missing dependencies, it can return an appropriate error status instead of inefficiently processing doomed requests.</li><li><strong>Optimize Resource Utilization</strong>: Prevent wasted resources in production by ensuring that only healthy instances handle user traffic. This goes a long way towards <a href=https://en.wikipedia.org/wiki/Green_computing>green IT</a> and cost reduction for processing
heavy requests.</li></ul><h3 id=expose-more-than-just-basic-availability>Expose More Than Just Basic Availability<a hidden class=anchor aria-hidden=true href=#expose-more-than-just-basic-availability>#</a></h3><p>Basic health checks only confirm whether an application is running, but Complete Health Checks provide deeper insights into system health.</p><ul><li><strong>Instant Cache Status Visibility</strong>: A well-implemented health check can report if cache layers (e.g., Redis, Memcached)
are operational, helping diagnose performance bottlenecks.</li><li><strong>Granular System Insights</strong>: Instead of a binary &ldquo;up or down&rdquo; status, a more granular health check endpoint can return structured
data about application health, making it easier to debug issues before they escalate.</li></ul><h2 id=how-to-set-them-up>How to set them up<a hidden class=anchor aria-hidden=true href=#how-to-set-them-up>#</a></h2><p>As a proper, hands-on example, let&rsquo;s consider the following application:</p><ul><li>Small API using <a href=https://fastapi.tiangolo.com/>FastAPI</a></li><li>Caching using <a href=https://redis.io/docs/latest/>Redis</a></li><li>Backend database storage using <a href=https://www.postgresql.org/>postgresql</a></li></ul><p>It translates into the following diagram:</p><p><img loading=lazy src=./api-diagram.png#center alt="architecture diagram"></p><p>Here, the API will use the cache to reduce the stress on our database and
third party calls.</p><p>To properly implement a Complete Health Check, we need to ensure that
we can reach both our Redis and our PostgreSQL dependencies.</p><ul><li>Redis: performing a <a href=https://redis.io/docs/latest/commands/ping/><code>ping</code></a> command.</li><li>PostgreSQL: executing a <code>SELECT 1;</code> statement against our database.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>perform_full_healthcheck</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># ensure redis can be reached</span>
</span></span><span class=line><span class=cl>    <span class=n>redis_client</span><span class=o>.</span><span class=n>ping</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># ensure postgres can be reached and we have read permission</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>psycopg2</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=n>DB_URL</span><span class=p>)</span> <span class=k>as</span> <span class=n>conn</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span> <span class=k>as</span> <span class=n>cur</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;SELECT 1;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span><span class=o>.</span><span class=n>fetchone</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>True</span></span></span></code></pre></td></tr></table></div></div><p>We can proceed to include our complete health check as another route in our application:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s2>&#34;/health-full&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>perform_health_check</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>complete_check_successful</span> <span class=o>=</span> <span class=n>perform_full_healthcheck</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;full health check works!&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>err</span><span class=p>:</span>  <span class=c1># something went wrong</span>
</span></span><span class=line><span class=cl>	<span class=c1># we have to return any non-2XX status code</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;full health check does not work&#34;</span><span class=p>},</span> <span class=mi>500</span></span></span></code></pre></td></tr></table></div></div><p>Most of the services only support a single strategy for health checks, meaning that for a
given &ldquo;health check&rdquo; initiator (i.e.: <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/application/target-group-health-checks.html>AWS Application Load Balancer</a>),
which means that:</p><ol><li>we don&rsquo;t want to spam our database or cache instance</li><li>once the &ldquo;full setup&rdquo; is done, we can switch to the default &ldquo;serve requests&rdquo; check</li></ol><p>This can be implemented using the following pattern:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s2>&#34;/health&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>perform_health_check</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>full_health_check_performed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;simple health check works!&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>complete_check_successful</span> <span class=o>=</span> <span class=n>perform_full_healthcheck</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>complete_check_successful</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>full_health_check_performed</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;full health check works!&#34;</span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>In the above snippet, we assume that we use global variables to simplify
switching between readiness and healthiness when using the same endpoint.</p><blockquote><p><em>Ideally we use 2 distinct endpoints but some orchestration services only
allow a single endpoint to be tested for healthiness.</em></p></blockquote><h2 id=liveness-vs-readinesss>Liveness vs readinesss<a hidden class=anchor aria-hidden=true href=#liveness-vs-readinesss>#</a></h2><p>Health checks in modern cloud environments typically fall into two categories: <strong>liveness checks</strong> and <strong>readiness checks</strong>. Understanding the distinction is crucial when designing a robust health check strategy.</p><p><strong>Liveness Checks: Ensuring the Application is Running</strong><br>A <strong>liveness check</strong> determines whether the application process is alive and capable of serving requests. This is what most standard health checks do—they simply confirm that the service is reachable and responding to HTTP requests.</p><ul><li>Used by <strong>load balancers</strong>, <strong>orchestrators</strong> (ECS, Kubernetes), and <strong>service meshes</strong> to determine whether a container should continue running.</li><li>If a liveness check fails, the container is typically restarted.</li><li>Examples:<ul><li>Responding with an HTTP 200 status from a <code>/health</code> endpoint.</li><li>Checking if the process is still running using a command like <code>pgrep my-service</code>.</li></ul></li></ul><p><strong>Readiness Checks: Ensuring the Application is Ready to Handle Traffic</strong><br>A <strong>readiness check</strong> is a more advanced health check that verifies whether the application is fully initialized and ready to serve traffic. It does not just check if the process is running but also ensures all dependencies (database, cache, external APIs) are in a good state.</p><ul><li>Used by <strong>load balancers</strong>, <strong>Kubernetes probes</strong>, and <strong>container orchestrators</strong> to determine when an instance should start receiving traffic.</li><li>Unlike liveness checks, failing a readiness check does not trigger a restart—it simply removes the instance from the traffic pool.</li><li>Examples:<ul><li>Checking if the database connection is live before marking the service as ready.</li><li>Validating access to an external API or cache system.</li></ul></li></ul><p><strong>Complete Health Check: A Readiness Check for Real-World Deployments</strong><br>A <strong>Complete Health Check</strong> is effectively a readiness check that goes beyond simple &ldquo;reachability&rdquo; checks. Instead of just verifying if the application is running, it ensures the service is in a state where it can properly handle requests.</p><ul><li><strong>Best used for validating configurations and dependencies before accepting traffic.</strong></li><li>Can be implemented at the <strong>container image level</strong> using an entry point script or a dedicated health check.</li><li>Ensures that misconfigured or partially initialized instances do not serve traffic.</li></ul><p><strong>Implementation Examples (ECS, Kubernetes)</strong><br>Complete Health Checks can be integrated into common cloud environments like ECS and Kubernetes.</p><p>Here we consider the <code>/health</code> route to return the standard health check and the <code>/health-full</code>
acts as the complete health check.</p><p><strong>Kubernetes:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/health</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>readinessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/health-full</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span></code></pre></div><ul><li>The liveness probe ensures the container is running.</li><li>The readiness probe ensures the container is ready before accepting traffic.</li></ul><p><em>Check the corresponding <a href=https://kubernetes.io/docs/concepts/configuration/liveness-readiness-startup-probes/>Kubernetes documentation on Liveness, Readiness (and Startup) probes</a>.</em></p><p><strong>AWS ECS (Fargate/EC2-backed tasks):</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=s2>&#34;healthCheck&#34;</span><span class=err>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;command&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;CMD-SHELL&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;curl -f http://localhost:8080/health-full || exit 1&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;interval&#34;</span><span class=p>:</span> <span class=mi>30</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;timeout&#34;</span><span class=p>:</span> <span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;retries&#34;</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;startPeriod&#34;</span><span class=p>:</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>The ECS task only joins the service once it passes the readiness check.</li><li>A failing readiness check removes the task from the load balancer without restarting it.</li></ul><p><em>Feel free to check <a href=https://docs.aws.amazon.com/AmazonECS/latest/developerguide/healthcheck.html>the dedicated documentation</a> for a deeper understanding of how health checks
work in ECS.</em></p><p><strong>Combining Multiple Health Check Sources</strong>:</p><p>Complete Health Checks provide more granular health insights, making them valuable
for multiple system components:</p><ul><li><strong>Load Balancer (ALB, NLB, API Gateway)</strong>: Uses health checks to determine if an instance should receive traffic.</li><li><strong>Container Orchestrator (Kubernetes, ECS)</strong>: Uses readiness probes to decide when an instance is ready for service.</li><li><strong>ECS Task-Level Health Check</strong>: Ensures that only fully configured instances join the service.</li></ul><p>By leveraging both <strong>liveness</strong> and <strong>readiness</strong> checks correctly,
applications can achieve higher availability, prevent misconfigured
deployments, and optimize request handling.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Implementing both liveness and readiness checks ensures that your application
remains not just available, but fully operational and efficient.
This approach helps catch misconfigurations early, optimizes resource
usage, and prevents unnecessary downtime.</p><p>No matter the deployment platform <a href=https://kubernetes.io/>Kubernetes</a>, <a href=https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html>ECS</a> or anything that
supports health checks integrating these checks strengthens
reliability and predictability.</p><p>Want to see a minimal implementation? Check it out here: <a href=https://github.com/tbobm/complete-health-checks-design>complete-health-checks-design</a></p><p>Feel free to reach out if you have feedbacks or questions !</p><p><a href=https://linkedin.com/in/tbobm/>Theo &ldquo;Bob&rdquo; Massard</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>In regard to our application&rsquo;s code, here we consider <strong>3rd party application</strong> anything that
we interact with and that we would want to test, such as Databases, Message Brokers, &mldr;.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>This can be handled at the <a href=https://en.wikipedia.org/wiki/Service_mesh>service mesh</a> level if any&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.tbobm.dev/tags/tech/>tech</a></li><li><a href=https://blog.tbobm.dev/tags/reliability/>reliability</a></li><li><a href=https://blog.tbobm.dev/tags/optimization/>optimization</a></li></ul><nav class=paginav><a class=next href=https://blog.tbobm.dev/posts/watermarking-pictures-fast/><span class=title>Next »</span><br><span>Watermarking pictures (fast) using Pillow and Libvips</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.tbobm.dev>tbobm.dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>