<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Multi-stage container images from dev to production | tbobm.dev</title>
<meta name=keywords content="tech,containers,go,tips,short"><meta name=description content='Multi-stage container images have been a good friend of mine for some time now. They enable projects to package smarter by splitting the build and run phases of a given software.
Intro to multi-stage Let&rsquo;s start with a simple hello world program in Go!
Here is a minimal working example that will be used for our next builds:
package main import "fmt" func main() { fmt.Println("Hello from Lambda! :)") } And our initial, easy to use, Dockerfile will look like this:'><meta name=author content='Theo "Bob" Massard'><link rel=canonical href=https://blog.tbobm.dev/posts/multistage-container-images-lambda/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.tbobm.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.tbobm.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.tbobm.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.tbobm.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.tbobm.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.tbobm.dev/posts/multistage-container-images-lambda/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-TH8WFGGJBS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TH8WFGGJBS")}</script><meta property="og:title" content="Multi-stage container images from dev to production"><meta property="og:description" content='Multi-stage container images have been a good friend of mine for some time now. They enable projects to package smarter by splitting the build and run phases of a given software.
Intro to multi-stage Let&rsquo;s start with a simple hello world program in Go!
Here is a minimal working example that will be used for our next builds:
package main import "fmt" func main() { fmt.Println("Hello from Lambda! :)") } And our initial, easy to use, Dockerfile will look like this:'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.tbobm.dev/posts/multistage-container-images-lambda/"><meta property="og:image" content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-16T15:20:00+02:00"><meta property="article:modified_time" content="2025-08-16T15:20:00+02:00"><meta property="og:site_name" content="tbobm.dev"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Multi-stage container images from dev to production"><meta name=twitter:description content='Multi-stage container images have been a good friend of mine for some time now. They enable projects to package smarter by splitting the build and run phases of a given software.
Intro to multi-stage Let&rsquo;s start with a simple hello world program in Go!
Here is a minimal working example that will be used for our next builds:
package main import "fmt" func main() { fmt.Println("Hello from Lambda! :)") } And our initial, easy to use, Dockerfile will look like this:'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.tbobm.dev/posts/"},{"@type":"ListItem","position":2,"name":"Multi-stage container images from dev to production","item":"https://blog.tbobm.dev/posts/multistage-container-images-lambda/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Multi-stage container images from dev to production","name":"Multi-stage container images from dev to production","description":"Multi-stage container images have been a good friend of mine for some time now. They enable projects to package smarter by splitting the build and run phases of a given software.\nIntro to multi-stage Let\u0026rsquo;s start with a simple hello world program in Go!\nHere is a minimal working example that will be used for our next builds:\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello from Lambda! :)\u0026#34;) } And our initial, easy to use, Dockerfile will look like this:","keywords":["tech","containers","go","tips","short"],"articleBody":"Multi-stage container images have been a good friend of mine for some time now. They enable projects to package smarter by splitting the build and run phases of a given software.\nIntro to multi-stage Let’s start with a simple hello world program in Go!\nHere is a minimal working example that will be used for our next builds:\npackage main import \"fmt\" func main() { fmt.Println(\"Hello from Lambda! :)\") } And our initial, easy to use, Dockerfile will look like this:\nFROM golang:1.24 AS builder COPY go.mod . COPY . . RUN go build -o /my-executable CMD [\"/my-executable\"] Building this gives an astonishing 888 MB image, thanks to all the development and build dependencies baked into golang:1.24. This will be our baseline.\nMulti-stage containers, as stated in the Docker documentation, allow us to strip away dev/build dependencies from the final image. This reduces:\nImage size Attack surface (security folks love that) Pull and start-up overhead Over time, I’ve even experimented with introducing a testing stage in container builds, but I eventually settled into the more common pattern: use multi-stage to get lean production images.\nTools like uv now offer fine-grained, cache-enabled build workflows, making this pattern even more attractive.\nThey have an excellent documentation on that on Using uv in Docker.\nSimple multi-stage example Let’s leverage scratch images for the smallest possible image. Using our initial container image, we will build the go executable, then copy it into a scratch image which does not include any filesystem.\nFROM golang:1.24 AS builder COPY go.mod . COPY . . RUN go build -o /my-executable FROM scratch AS release COPY --from=builder /my-executable /my-executable CMD [\"/my-executable\"] In the above file, the builder stage includes every tool required to create the golang executable, which we then retrieve in the release stage by using the COPY --from= directive.\nThe final resulting image is made of only our executable in an empty base image. Now the final image is only 2.21 MB. Hard to beat without more complex build system configuration.\nHowever, scratch images may be hard to use in production: no shell, no package manager, no libraries.\nWe can work around that using side-car containers if our orchestration engine allows it but if we want to stick to a independant container image, we can use a more flexible base image.\nUsing distroless images A neat middle ground is provided by distroless images: they’re slim, minimal images with just the runtime libraries needed to execute your program.\nHere’s our Go example adapted to a distroless base:\nFROM golang:1.24 AS builder COPY go.mod . COPY . . RUN go build -o /my-executable FROM gcr.io/distroless/static-debian12 AS release COPY --from=builder /my-executable /my-executable CMD [\"/my-executable\"] This gives you:\nSmall footprint Runtime libraries included Slightly better debugging and operational capabilities than scratch distroless images can also be custom-built using Bazel rules if you need more control or want to extend the capabilities included in th end result image.\nBase Image comparison Build type Base image Approx. size Notes Single-stage golang:1.24 ~888 MB Includes full Go toolchain and build deps Two-stage (scratch) scratch ~2.2 MB Smallest possible image, no OS libs/tools Two-stage (distroless) gcr.io/distroless/static-debian12 ~8–10 MB Minimal OS libs included, better prod support Sizes will vary depending on your binary and build flags. Scratch is the smallest but lacks runtime tooling, while distroless offers a good security-functionality balance.\nGoing further - AWS Lambda support I love AWS Lambda. I love Go. Now, I do Lambdas in Go. Quick maths.\nOne thing I always want for my Lambdas is local execution. My go-to solution is the Lambda Runtime Interface Emulator (RIE) because it’s so simple to integrate and works with LocalStack for a cloud-like local workflow.\nLet’s consider the following hello world Lambda code in go:\npackage main import ( \"context\" \"encoding/json\" \"fmt\" \"github.com/aws/aws-lambda-go/lambda\" ) type Response struct { Message string `json:\"message\"` } func handler(ctx context.Context) (json.RawMessage, error) { resp := Response{ Message: \"Hello from Lambda :)\", } data, err := json.Marshal(resp) if err != nil { return nil, fmt.Errorf(\"failed to marshal response: %w\", err) } return data, nil } func main() { lambda.Start(handler) } And here is a multi-stage Dockerfile for a Go-based Lambda:\nFROM golang:1.24 AS build WORKDIR /app COPY go.mod go.sum ./ COPY . . RUN go build -tags lambda.norpc -o my-lambda FROM public.ecr.aws/lambda/provided:al2023 AS production COPY --from=build /app/my-lambda ./my-lambda ENTRYPOINT [ \"./my-lambda\" ] FROM production AS dev RUN mkdir -p /aws-lambda-rie \u0026\u0026 \\ curl -Lo /aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie \u0026\u0026 \\ chmod +x /aws-lambda-rie/aws-lambda-rie ENTRYPOINT [ \"/aws-lambda-rie/aws-lambda-rie\", \"./my-lambda\" ] The core of our program is now packaged and made available within the production stage defined in our Dockerfile, but is extended in the dev stage to include the program that enables running Lambda locally easily.\nThis setup allows:\nA production-ready image A dev variant with local HTTP interface via RIE Build commands:\n$ docker build -t lambda:prod --target production . $ docker build -t lambda:dev --target dev . $ docker build -t lambda:default . # defaults to dev I often default to production by ending the Dockerfile with:\nFROM production AS release This last instructions at the bottom of the Dockerfile makes the production stage the default one by creating a new release stage.\nNow, the default image is the production one:\n$ docker build -t lambda:default . # now \"release\" based on production This will exclude the Lambda RIE addition from our container image but we still have local dev support through the dev target, ensuring parity. Our Dockerfile covers both dev and production.\nLocal invocation example with RIE Once you’ve built the dev target with Lambda RIE included:\ndocker build -t lambda:dev --target dev . You can run it locally, binding the Lambda’s HTTP interface to a port:\ndocker run --rm -p 9000:8080 lambda:dev Now send an event to it using curl:\ncurl -XPOST \\ \"http://localhost:9000/2015-03-31/functions/function/invocations\" \\ -d '{}' Expected output:\n{\"statusCode\":200,\"body\":\"Hello from Lambda :)\"} Conclusion Multi-stage builds are one of those container building features that are often overlooked at the early stages of a project.\nHowever, multi-stage is easy to implement and it enables:\nLighter images, improving cost and performances Cleaner CI/CD pipelines, with a flexible single image Local dev and production parity, as we only maintain a single Dockerfile Below is a small diagram to represent the different stages of our container image and how they interact with each other.\nBelow is the source code of this mermaid diagram\n--- config: theme: neutral layout: elk look: handDrawn --- flowchart TB subgraph subGraph0[\"Build Stage\"] B[\"/my-executable\"] A[\"golang:1.24\"] end subgraph subGraph1[\"Production Stage\"] C[\"scratch / distroless / lambda:prod\"] end subgraph subGraph2[\"Dev Stage (Optional)\"] D[\"lambda:dev\"] E[(\"Local HTTP endpoint\")] end subgraph subGraph3[\"Release Stage\"] P[\"Production image\"] end A -- compile Go binary --\u003e B B --\u003e C C --\u003e D \u0026 P D -- add Lambda RIE --\u003e E In combination with tools like distroless or Lambda RIE, and you get both security and convenience.\nYou can check out the corresponding example repository here: multistage-container-images-example\nFeel free to reach out if you have feedback or questions!\nTheo “Bob” Massard\n","wordCount":"1164","inLanguage":"en","image":"https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-08-16T15:20:00+02:00","dateModified":"2025-08-16T15:20:00+02:00","author":{"@type":"Person","name":"Theo \"Bob\" Massard"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tbobm.dev/posts/multistage-container-images-lambda/"},"publisher":{"@type":"Organization","name":"tbobm.dev","logo":{"@type":"ImageObject","url":"https://blog.tbobm.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.tbobm.dev/ accesskey=h title="tbobm.dev (Alt + H)">tbobm.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.tbobm.dev/about/ title=about><span>about</span></a></li><li><a href=https://blog.tbobm.dev/now/ title=now><span>now</span></a></li><li><a href=https://blog.tbobm.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.tbobm.dev/>Home</a>&nbsp;»&nbsp;<a href=https://blog.tbobm.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Multi-stage container images from dev to production</h1><div class=post-meta><span title='2025-08-16 15:20:00 +0200 +0200'>August 16, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1164 words&nbsp;·&nbsp;Theo "Bob" Massard&nbsp;|&nbsp;<a href=https://github.com/tbobm/tbobm-blog/content/posts/multistage-container-images-lambda/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro-to-multi-stage>Intro to multi-stage</a><ul><li><a href=#simple-multi-stage-example>Simple multi-stage example</a></li><li><a href=#using-distroless-images>Using distroless images</a></li><li><a href=#base-image-comparison>Base Image comparison</a></li></ul></li><li><a href=#going-further---aws-lambda-support>Going further - AWS Lambda support</a><ul><li><a href=#local-invocation-example-with-rie>Local invocation example with RIE</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p><a href=https://docs.docker.com/build/building/multi-stage/>Multi-stage container</a> images have been a good friend of mine for some time now.
They enable projects to package smarter by splitting the <strong>build</strong> and <strong>run</strong> phases of a given software.</p><h2 id=intro-to-multi-stage>Intro to multi-stage<a hidden class=anchor aria-hidden=true href=#intro-to-multi-stage>#</a></h2><p>Let&rsquo;s start with a simple <strong>hello world</strong> program in Go!</p><p>Here is a minimal working example that will be used for our next builds:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Hello from Lambda! :)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And our initial, easy to use, Dockerfile will look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:1.24 AS builder</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> go.mod .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go build -o /my-executable<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;/my-executable&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>Building this gives an astonishing <strong>888 MB</strong> image, thanks to all the development and build dependencies baked into <a href=https://hub.docker.com/_/golang><code>golang:1.24</code></a>.
This will be our <strong>baseline</strong>.</p><p>Multi-stage containers, as stated in the Docker documentation, allow us to strip away dev/build dependencies from the final image.
This reduces:</p><ul><li><strong>Image size</strong></li><li><strong>Attack surface</strong> (security folks love that)</li><li><strong>Pull and start-up overhead</strong></li></ul><p>Over time, I’ve even experimented with introducing a <strong>testing stage</strong> in container builds, but I eventually settled into the more common pattern:
use multi-stage to get <strong>lean production images</strong>.</p><p>Tools like <code>uv</code> now offer fine-grained, cache-enabled build workflows, making this pattern even more attractive.</p><p>They have an excellent documentation on that on <a href=https://docs.astral.sh/uv/guides/integration/docker/>Using uv in Docker</a>.</p><h3 id=simple-multi-stage-example>Simple multi-stage example<a hidden class=anchor aria-hidden=true href=#simple-multi-stage-example>#</a></h3><p>Let’s leverage <a href=https://hub.docker.com/_/scratch>scratch images</a> for the smallest possible image.
Using our initial container image, we will build the go executable, then copy it
into a scratch image which does not include any filesystem.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:1.24 AS builder</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> go.mod .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go build -o /my-executable<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> scratch AS release</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder /my-executable /my-executable<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;/my-executable&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>In the above file, the <code>builder</code> stage includes every tool required to
create the golang executable, which we then retrieve in the <code>release</code>
stage by using the <a href=https://docs.docker.com/reference/dockerfile/#copy---from><code>COPY --from=&lt;stage></code></a> directive.</p><p>The final resulting image is made of only our executable in an empty base image.
Now the final image is only <strong>2.21 MB</strong>.
Hard to beat without more complex build system configuration.</p><p><strong>However, scratch images may be hard to use in production</strong>: no shell, no package manager, no libraries.</p><p>We can work around that using side-car containers if our orchestration engine allows it but if we
want to stick to a independant container image, we can use a more flexible base image.</p><h3 id=using-distroless-images>Using distroless images<a hidden class=anchor aria-hidden=true href=#using-distroless-images>#</a></h3><p>A neat middle ground is provided by <a href=https://github.com/GoogleContainerTools/distroless>distroless images</a>:
they’re slim, minimal images with just the runtime libraries needed to execute your program.</p><p>Here’s our Go example adapted to a distroless base:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:1.24 AS builder</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> go.mod .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go build -o /my-executable<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> gcr.io/distroless/static-debian12 AS release</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder /my-executable /my-executable<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;/my-executable&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>This gives you:</p><ul><li>Small footprint</li><li>Runtime libraries included</li><li>Slightly better debugging and operational capabilities than <code>scratch</code></li></ul><p><code>distroless</code> images can also be <strong>custom-built</strong> using <a href=https://github.com/GoogleContainerTools/rules_distroless/tree/main>Bazel rules</a> if you need more control
or want to extend the capabilities included in th end result image.</p><h3 id=base-image-comparison>Base Image comparison<a hidden class=anchor aria-hidden=true href=#base-image-comparison>#</a></h3><table><thead><tr><th>Build type</th><th>Base image</th><th>Approx. size</th><th>Notes</th></tr></thead><tbody><tr><td><strong>Single-stage</strong></td><td><code>golang:1.24</code></td><td>~888 MB</td><td>Includes full Go toolchain and build deps</td></tr><tr><td><strong>Two-stage (scratch)</strong></td><td><code>scratch</code></td><td>~2.2 MB</td><td>Smallest possible image, no OS libs/tools</td></tr><tr><td><strong>Two-stage (distroless)</strong></td><td><code>gcr.io/distroless/static-debian12</code></td><td>~8–10 MB</td><td>Minimal OS libs included, better prod support</td></tr></tbody></table><blockquote><p>Sizes will vary depending on your binary and build flags.
Scratch is the smallest but lacks runtime tooling, while distroless offers a good security-functionality balance.</p></blockquote><h2 id=going-further---aws-lambda-support>Going further - AWS Lambda support<a hidden class=anchor aria-hidden=true href=#going-further---aws-lambda-support>#</a></h2><p><em>I love AWS Lambda. I love Go. Now, I do Lambdas in Go. Quick maths.</em></p><p>One thing I always want for my Lambdas is <strong>local execution</strong>.
My go-to solution is the <strong><a href=https://github.com/aws/aws-lambda-runtime-interface-emulator>Lambda Runtime Interface Emulator (RIE)</a></strong> because it’s so
simple to integrate and works with <a href=https://github.com/localstack/localstack>LocalStack</a> for a cloud-like local workflow.</p><p>Let&rsquo;s consider the following hello world Lambda code in go:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;encoding/json&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/aws/aws-lambda-go/lambda&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Response</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Message</span> <span class=kt>string</span> <span class=s>`json:&#34;message&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>handler</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>(</span><span class=nx>json</span><span class=p>.</span><span class=nx>RawMessage</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>resp</span> <span class=o>:=</span> <span class=nx>Response</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Message</span><span class=p>:</span> <span class=s>&#34;Hello from Lambda :)&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>data</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>resp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;failed to marshal response: %w&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>data</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>lambda</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>handler</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And here is a multi-stage <code>Dockerfile</code> for a Go-based Lambda:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:1.24 AS build</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> go.mod go.sum ./<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go build -tags lambda.norpc -o my-lambda<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> public.ecr.aws/lambda/provided:al2023 AS production</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>build /app/my-lambda ./my-lambda<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span> <span class=s2>&#34;./my-lambda&#34;</span> <span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> production AS dev</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mkdir -p /aws-lambda-rie <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    curl -Lo /aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    chmod +x /aws-lambda-rie/aws-lambda-rie<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span> <span class=s2>&#34;/aws-lambda-rie/aws-lambda-rie&#34;</span><span class=p>,</span> <span class=s2>&#34;./my-lambda&#34;</span> <span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>The core of our program is now packaged and made available within the <code>production</code> stage
defined in our Dockerfile, but is extended in the <code>dev</code> stage to include the program that
enables running Lambda locally easily.</p><p>This setup allows:</p><ul><li>A <strong>production-ready image</strong></li><li>A <strong>dev variant</strong> with local HTTP interface via RIE</li></ul><p>Build commands:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> docker build -t lambda:prod --target production .
</span></span><span class=line><span class=cl><span class=gp>$</span> docker build -t lambda:dev --target dev .
</span></span><span class=line><span class=cl><span class=gp>$</span> docker build -t lambda:default .  <span class=c1># defaults to dev</span>
</span></span></code></pre></div><p>I often <strong>default to production</strong> by ending the Dockerfile with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> production AS release</span><span class=err>
</span></span></span></code></pre></div><p>This last instructions at the bottom of the Dockerfile makes the <code>production</code>
stage the default one by creating a new <code>release</code> stage.</p><p>Now, the default image is the production one:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> docker build -t lambda:default .  <span class=c1># now &#34;release&#34; based on production</span>
</span></span></code></pre></div><p>This will exclude the Lambda RIE addition from our container image
but we still have <strong>local dev support</strong> through the <code>dev</code> target,
ensuring parity. Our Dockerfile covers both <strong>dev</strong> and <strong>production</strong>.</p><h3 id=local-invocation-example-with-rie>Local invocation example with RIE<a hidden class=anchor aria-hidden=true href=#local-invocation-example-with-rie>#</a></h3><p>Once you’ve built the <code>dev</code> target with Lambda RIE included:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t lambda:dev --target dev .
</span></span></code></pre></div><p>You can run it locally, binding the Lambda’s HTTP interface to a port:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run --rm -p 9000:8080 lambda:dev
</span></span></code></pre></div><p>Now send an event to it using <code>curl</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -XPOST <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=s2>&#34;http://localhost:9000/2015-03-31/functions/function/invocations&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -d <span class=s1>&#39;{}&#39;</span>
</span></span></code></pre></div><p>Expected output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span><span class=nt>&#34;statusCode&#34;</span><span class=p>:</span><span class=mi>200</span><span class=p>,</span><span class=nt>&#34;body&#34;</span><span class=p>:</span><span class=s2>&#34;Hello from Lambda :)&#34;</span><span class=p>}</span>
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Multi-stage builds are one of those container building features that are often overlooked at the early stages of a project.</p><p>However, multi-stage is easy to implement and it enables:</p><ul><li><strong>Lighter images</strong>, improving cost and performances</li><li><strong>Cleaner CI/CD pipelines</strong>, with a flexible single image</li><li><strong>Local dev and production parity</strong>, as we only maintain a single Dockerfile</li></ul><p>Below is a small diagram to represent the different stages of our container image
and how they interact with each other.</p><p><img loading=lazy src=./build-pipeline.png alt=visualize-multi-stage></p><p><em>Below is the source code of this mermaid diagram</em></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>---
config:
  theme: neutral
  layout: elk
  look: handDrawn
---
flowchart TB
 subgraph subGraph0[&#34;Build Stage&#34;]
        B[&#34;/my-executable&#34;]
        A[&#34;golang:1.24&#34;]
  end
 subgraph subGraph1[&#34;Production Stage&#34;]
        C[&#34;scratch / distroless / lambda:prod&#34;]
  end
 subgraph subGraph2[&#34;Dev Stage (Optional)&#34;]
        D[&#34;lambda:dev&#34;]
        E[(&#34;Local HTTP endpoint&#34;)]
  end
 subgraph subGraph3[&#34;Release  Stage&#34;]
        P[&#34;Production image&#34;]
  end
    A -- compile Go binary --&gt; B
    B --&gt; C
    C --&gt; D &amp; P
    D -- add Lambda RIE --&gt; E
</code></pre><p>In combination with tools like <a href=https://github.com/GoogleContainerTools/distroless><code>distroless</code></a> or <a href=https://github.com/aws/aws-lambda-runtime-interface-emulator>Lambda RIE</a>, and you get both security and convenience.</p><p>You can check out the corresponding example repository here: <a href=https://github.com/tbobm/multistage-container-images-example>multistage-container-images-example</a></p><p>Feel free to reach out if you have feedback or questions!</p><p><a href=https://linkedin.com/in/tbobm/>Theo &ldquo;Bob&rdquo; Massard</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.tbobm.dev/tags/tech/>Tech</a></li><li><a href=https://blog.tbobm.dev/tags/containers/>Containers</a></li><li><a href=https://blog.tbobm.dev/tags/go/>Go</a></li><li><a href=https://blog.tbobm.dev/tags/tips/>Tips</a></li><li><a href=https://blog.tbobm.dev/tags/short/>Short</a></li></ul><nav class=paginav><a class=next href=https://blog.tbobm.dev/posts/db-bootstrapping/><span class=title>Next »</span><br><span>Bootstrapping SQL databases for local and production setup</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.tbobm.dev/>tbobm.dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>