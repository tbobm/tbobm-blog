<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Watermarking pictures (fast) using Pillow and Libvips | tbobm.dev</title><meta name=keywords content="media processing,performance,python,go,tech"><meta name=description content="Working in the media processing industry, I very often encounter 2 concepts: adding overlay to images and doing it fast.
As I&rsquo;m very much interested in tackling this problem well enough and using proper tooling for performance efficiency, I explored several options that allow watermarking pictures.
Code is available at github.com/tbobm/watermarking-images-for-fun-and-profit
Watermarking pictures To put things back in context, watermarking is the act of applying an overlay to a media. This can be performed through many different operation and is used to apply branding, establish ownership, or limit usage to a specific audience 1."><meta name=author content="Theo &#34;Bob&#34; Massard"><link rel=canonical href=https://blog.tbobm.dev/posts/watermarking-pictures-fast/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.tbobm.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.tbobm.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.tbobm.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.tbobm.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.tbobm.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-TH8WFGGJBS"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TH8WFGGJBS",{anonymize_ip:!1})}</script><meta property="og:title" content="Watermarking pictures (fast) using Pillow and Libvips"><meta property="og:description" content="Working in the media processing industry, I very often encounter 2 concepts: adding overlay to images and doing it fast.
As I&rsquo;m very much interested in tackling this problem well enough and using proper tooling for performance efficiency, I explored several options that allow watermarking pictures.
Code is available at github.com/tbobm/watermarking-images-for-fun-and-profit
Watermarking pictures To put things back in context, watermarking is the act of applying an overlay to a media. This can be performed through many different operation and is used to apply branding, establish ownership, or limit usage to a specific audience 1."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.tbobm.dev/posts/watermarking-pictures-fast/"><meta property="og:image" content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-13T13:35:00+02:00"><meta property="article:modified_time" content="2024-11-13T13:35:00+02:00"><meta property="og:site_name" content="tbobm.dev"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Watermarking pictures (fast) using Pillow and Libvips"><meta name=twitter:description content="Working in the media processing industry, I very often encounter 2 concepts: adding overlay to images and doing it fast.
As I&rsquo;m very much interested in tackling this problem well enough and using proper tooling for performance efficiency, I explored several options that allow watermarking pictures.
Code is available at github.com/tbobm/watermarking-images-for-fun-and-profit
Watermarking pictures To put things back in context, watermarking is the act of applying an overlay to a media. This can be performed through many different operation and is used to apply branding, establish ownership, or limit usage to a specific audience 1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.tbobm.dev/posts/"},{"@type":"ListItem","position":2,"name":"Watermarking pictures (fast) using Pillow and Libvips","item":"https://blog.tbobm.dev/posts/watermarking-pictures-fast/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Watermarking pictures (fast) using Pillow and Libvips","name":"Watermarking pictures (fast) using Pillow and Libvips","description":"Working in the media processing industry, I very often encounter 2 concepts: adding overlay to images and doing it fast.\nAs I\u0026rsquo;m very much interested in tackling this problem well enough and using proper tooling for performance efficiency, I explored several options that allow watermarking pictures.\nCode is available at github.com/tbobm/watermarking-images-for-fun-and-profit\nWatermarking pictures To put things back in context, watermarking is the act of applying an overlay to a media. This can be performed through many different operation and is used to apply branding, establish ownership, or limit usage to a specific audience 1.","keywords":["media processing","performance","python","go","tech"],"articleBody":"Working in the media processing industry, I very often encounter 2 concepts: adding overlay to images and doing it fast.\nAs I’m very much interested in tackling this problem well enough and using proper tooling for performance efficiency, I explored several options that allow watermarking pictures.\nCode is available at github.com/tbobm/watermarking-images-for-fun-and-profit\nWatermarking pictures To put things back in context, watermarking is the act of applying an overlay to a media. This can be performed through many different operation and is used to apply branding, establish ownership, or limit usage to a specific audience 1.\nWatermarking can be applied to many different types of data but we’ll focus on images and more specifically, PNG overlays on JPEG files.\nThe main goal is to be able to just “apply” our overlay to the base image. I’ve been dealing with this setup in Python for a while and always ended up using Pillow but LibVips has also been around for quite a while and piqued my interest a couple months ago.\nTime went on and I finally drafted a short minimal working setup to compare those two libraries.\nInitial test scenario We will be using a simple JPEG file (1920x1080) as the base image and a small PNG overlay to explore the different implementations.\nsource: image of a heart shaped post-it overlay: black and white PNG of Bob the Builder. Python + Pillow My historical go-to library for interacting with images has always been “Good Old Pillow” which has been around for quite some time now.\nThe API is quite straight-forward and we can rely on Image.paste to apply the overlay to the source Image.\nsource = Image.open(SOURCE_IMAGE) overlay = Image.open(OVERLAY_IMAGE) position_x, position_y = (source.width - overlay.width) // 2, (source.height - overlay.height) // 2 # watermarking operation source.paste(overlay, (position_x, position_y), overlay) source.save(RESULT_IMAGE) We can run this code to generate our expected artifact, Bob the builder on the heart.\n$ poetry run python3 example_pillow/main.py $ feh watermarked.png We now have our expected output.\nLet’s see how this snippet behaves when run using hyperfine:\n$ hyperfine 'poetry run python3 example_pillow/main.py' Benchmark 1: poetry run python3 example_pillow/main.py Time (mean ± σ): 1.100 s ± 0.036 s [User: 2.540 s, System: 0.079 s] Range (min … max): 1.044 s … 1.160 s 10 runs Roughly 1.1s for the whole command execution, not bad. Let’s keep this number in mind for later.\nPython + Libvips Another candidate that I’ve been looking at for quite a while has been LibVips, a demand-driven, horizontally threaded image processing library. The benchmarks listed in their documentation are really interesting and I was eager to experiment with it.\nKnowing that it has Python bindings, we can duplicate and adapt our initial Pillow script to use PyVips.\nThe watermarking operation is performed using a pyvips.Image.composite2 method.\nsource = pyvips.Image.new_from_file(SOURCE_IMAGE) overlay = pyvips.Image.new_from_file(OVERLAY_IMAGE) position_x, position_y = (source.width - overlay.width) // 2, (source.height - overlay.height) // 2 # watermarking operation performed using composite2 watermarked = source.composite2(overlay, \"over\", x=position_x, y=position_y) watermarked.write_to_file(RESULT_IMAGE) We can now run our performance evaluation command:\n$ hyperfine 'poetry run python3 example_pyvips/main.py' Benchmark 1: poetry run python3 example_pyvips/main.py Time (mean ± σ): 1.330 s ± 0.044 s [User: 2.792 s, System: 0.141 s] Range (min … max): 1.277 s … 1.425 s 10 runs 1.33s? Odd. Expecting the library to be blazing fast, let’s keep this number in mind too. Everything will make sense in a very short moment.\nDive into the results By looking at script execution instead of operation duration, we also have unrelated processing taking up some part of the duration. We have, for instance:\nPython interpreter startup time I/O operations Module import duration Something that we often don’t see, especially when working on relatively small projects, is the potential impact of the whole execution performed under-the-hood of some modules we used. Some projects, when imported, will perform a set of actions such as bootstrapping dependencies, logging, …\nA few years ago, the Instagram Engineering team wrote about the concept of strict modules that would guarantee the absence of side effects. The concept in itself is great and can offer a lot of improvements, both for development and production workloads.\nBy checking the duration of both import statements, we can already have a hint:\nimport pillow: 0.069217s import pyvips: 0.172800s Naturally, I ended up diving a bit in both project’s (Pillow and PyVips) entrypoints and without any surprise, we can observe that PyVips’ entrypoint (__init__.py) is loading the LibVips bindings, configuring logging, … which can add up.\nConsidering that those values are not relevant for an actual long-lived service (i.e.: ECS Service) or an execution with a Warmed up environment (i.e.: Lambdas), we can safely dismiss those durations that correspond to “cold starts”.\nIf instead of observing the end-to-end processing, we only observe the actual watermarking operation by extracting this specific code snippet from our example code, we can have a much more accurate representation of a realistic calculation.\nWe can achieve this by fiddling around with the functools.partial method and the timeit module.\nOur Pillow function now looks like the following:\nimport timeit to_test = functools.partial(source.paste, overlay, (position_x, position_y), overlay) res = timeit.timeit(to_test, number=100000) print(res) And the PyVips function:\nimport timeit to_test = functools.partial(source.composite2, overlay, \"over\", x=position_x, y=position_y) res = timeit.timeit(to_test, number=100000) print(res) We end up with the following summary table:\nLibrary 100.000 watermarks Import module Single run duration Pillow 73.80s 00.046741s 1.10s PyVips 8.09s 00.174187s 1.33s As we can see, the tiny overhead that we initially observed with the single end to end script run timing is more than justified on PyVips’ end. By being nearly 10x faster to perform the same number operation, it’s easy to visualize the performance gains from using PyVips.\nHowever, as stated in their “Notes” section, LibVips is by default shining on multi-core systems, which is what I’m using.\nBonus: Golang + Libvips As a bonus and for the sake of trying it out, I put together a simple Go-based implementation. No surprise here, the whole program is going faster than both end to end Python implementation and the language overhead is slimmer than when using PyVips.\n// Load source and overlay images source, err := vips.NewImageFromFile(SOURCE_IMAGE) if err != nil { log.Fatalf(\"Failed to load source image: %v\", err) } defer source.Close() overlay, err := vips.NewImageFromFile(OVERLAY_IMAGE) if err != nil { log.Fatalf(\"Failed to load overlay image: %v\", err) } defer overlay.Close() // Resize overlay if necessary (optional) overlayWidth := overlay.Width() overlayHeight := overlay.Height() // Calculate position to center overlay on source x := (source.Width() - overlayWidth) / 2 y := (source.Height() - overlayHeight) / 2 // Composite overlay onto the source image with transparency err = source.Composite(overlay, vips.BlendModeOver, x, y) We can then build and execute the watermark-vips binary:\n$ go build $ hyperfine watermark-vips Benchmark 1: watermark-vips Time (mean ± σ): 292.2 ms ± 24.3 ms [User: 281.3 ms, System: 72.1 ms] Range (min … max): 252.6 ms … 321.3 ms 10 runs Of course, this has much more implications as it’s a completely different language, but it’s still great to know how much of a difference switching to Go could make in a specialized micro-service approach.\nObservations It was quite fun to take the time to try out different patterns and to highlight the performance differences (here, speed mostly) of both libraries I’ve been using for a while.\nThere is no right or wrong regarding library choice as Pillow still has plenty of usages, especially due to how easy it is to include in a project due to its “completeness” whereas PyVips’ plugin mechanism can sometimes include a “compile it yourself” step to support different file types.\nThe French Government developed filigrane.beta.gouv.fr, which can be used to mitigate fraud and scams ↩︎\n","wordCount":"1279","inLanguage":"en","image":"https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-11-13T13:35:00+02:00","dateModified":"2024-11-13T13:35:00+02:00","author":{"@type":"Person","name":"Theo \"Bob\" Massard"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tbobm.dev/posts/watermarking-pictures-fast/"},"publisher":{"@type":"Organization","name":"tbobm.dev","logo":{"@type":"ImageObject","url":"https://blog.tbobm.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.tbobm.dev accesskey=h title="tbobm.dev (Alt + H)">tbobm.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.tbobm.dev/about/ title=about><span>about</span></a></li><li><a href=https://blog.tbobm.dev/now/ title=now><span>now</span></a></li><li><a href=https://blog.tbobm.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.tbobm.dev>Home</a>&nbsp;»&nbsp;<a href=https://blog.tbobm.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Watermarking pictures (fast) using Pillow and Libvips</h1><div class=post-meta><span title='2024-11-13 13:35:00 +0200 +0200'>November 13, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1279 words&nbsp;·&nbsp;Theo "Bob" Massard&nbsp;|&nbsp;<a href=https://github.com/tbobm/tbobm-blog/content/posts/watermarking-pictures-fast/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#watermarking-pictures>Watermarking pictures</a></li><li><a href=#initial-test-scenario>Initial test scenario</a><ul><li><a href=#python--pillow>Python + Pillow</a></li><li><a href=#python--libvips>Python + Libvips</a></li><li><a href=#dive-into-the-results>Dive into the results</a></li><li><a href=#bonus-golang--libvips>Bonus: Golang + Libvips</a></li></ul></li><li><a href=#observations>Observations</a></li></ul></nav></div></details></div><div class=post-content><p>Working in the <em>media processing</em> industry, I very often encounter 2 concepts: <strong>adding overlay to images</strong> and <strong>doing it fast</strong>.</p><p>As I&rsquo;m very much interested in tackling this problem well enough and using proper tooling for performance efficiency, I explored several options that allow watermarking pictures.</p><blockquote><p>Code is available at <a href=https://github.com/tbobm/watermarking-images-for-fun-and-profit>github.com/tbobm/watermarking-images-for-fun-and-profit</a></p></blockquote><h2 id=watermarking-pictures>Watermarking pictures<a hidden class=anchor aria-hidden=true href=#watermarking-pictures>#</a></h2><p>To put things back in context, watermarking is the act of applying an <strong>overlay</strong> to a <strong>media</strong>.
This can be performed through many different operation and is used to apply branding, establish ownership, or <em>limit usage to a specific audience</em> <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Watermarking can be applied to many different types of data but we&rsquo;ll focus on <strong>images</strong> and
more specifically, PNG overlays on JPEG files.</p><p>The main goal is to be able to just &ldquo;apply&rdquo; our overlay to the base image. I&rsquo;ve been dealing with
this setup in Python for a while and always ended up using <a href=https://pillow.readthedocs.io/en/stable/>Pillow</a> but <a href=https://www.libvips.org/>LibVips</a> has also
been around for quite a while and piqued my interest a couple months ago.</p><p>Time went on and I finally drafted a short minimal working setup to compare those two libraries.</p><h2 id=initial-test-scenario>Initial test scenario<a hidden class=anchor aria-hidden=true href=#initial-test-scenario>#</a></h2><p>We will be using a simple JPEG file (1920x1080) as the base image and a small PNG overlay to explore
the different implementations.</p><p><em>source: image of a heart shaped post-it</em>
<img loading=lazy src=./source.jpg alt="source jpg image"></p><p><em>overlay: black and white PNG of Bob the Builder.</em>
<img loading=lazy src=./overlay.png#center alt="overlay png with bob the builder"></p><h3 id=python--pillow>Python + Pillow<a hidden class=anchor aria-hidden=true href=#python--pillow>#</a></h3><p>My historical go-to library for interacting with images has always been &ldquo;Good Old Pillow&rdquo;
which has been around for quite some time now.</p><p>The API is quite straight-forward and we can rely on <a href=https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.paste><code>Image.paste</code></a> to apply the overlay
to the source Image.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python3 data-lang=python3><span class=line><span class=cl><span class=n>source</span> <span class=o>=</span> <span class=n>Image</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=n>SOURCE_IMAGE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>overlay</span> <span class=o>=</span> <span class=n>Image</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=n>OVERLAY_IMAGE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>position_x</span><span class=p>,</span> <span class=n>position_y</span> <span class=o>=</span> <span class=p>(</span><span class=n>source</span><span class=o>.</span><span class=n>width</span> <span class=o>-</span> <span class=n>overlay</span><span class=o>.</span><span class=n>width</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>source</span><span class=o>.</span><span class=n>height</span> <span class=o>-</span> <span class=n>overlay</span><span class=o>.</span><span class=n>height</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=c1># watermarking operation</span>
</span></span><span class=line><span class=cl><span class=n>source</span><span class=o>.</span><span class=n>paste</span><span class=p>(</span><span class=n>overlay</span><span class=p>,</span> <span class=p>(</span><span class=n>position_x</span><span class=p>,</span> <span class=n>position_y</span><span class=p>),</span> <span class=n>overlay</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>source</span><span class=o>.</span><span class=n>save</span><span class=p>(</span><span class=n>RESULT_IMAGE</span><span class=p>)</span>
</span></span></code></pre></div><p>We can run this code to generate our expected artifact, Bob the builder on the heart.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> poetry run python3 example_pillow/main.py
</span></span><span class=line><span class=cl><span class=gp>$</span> feh watermarked.png
</span></span></code></pre></div><p><img loading=lazy src=./watermarked.png alt="watermarked image">
We now have our expected output.</p><p>Let&rsquo;s see how this snippet behaves when run using <a href=https://github.com/sharkdp/hyperfine><code>hyperfine</code></a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> hyperfine <span class=s1>&#39;poetry run python3 example_pillow/main.py&#39;</span>
</span></span><span class=line><span class=cl><span class=go>Benchmark 1: poetry run python3 example_pillow/main.py
</span></span></span><span class=line><span class=cl><span class=go>  Time (mean ± σ):      1.100 s ±  0.036 s    [User: 2.540 s, System: 0.079 s]
</span></span></span><span class=line><span class=cl><span class=go>  Range (min … max):    1.044 s …  1.160 s    10 runs
</span></span></span></code></pre></div><p>Roughly <strong>1.1s</strong> for the whole command execution, not bad.
Let&rsquo;s keep this number in mind for later.</p><h3 id=python--libvips>Python + Libvips<a hidden class=anchor aria-hidden=true href=#python--libvips>#</a></h3><p>Another candidate that I&rsquo;ve been looking at for quite a while has been <a href=https://www.libvips.org/>LibVips</a>,
<em>a demand-driven, horizontally threaded image processing library</em>. The <a href=https://github.com/libvips/libvips/wiki/Speed-and-memory-use>benchmarks</a> listed
in their documentation are really interesting and I was eager to experiment with it.</p><p>Knowing that it has Python bindings, we can duplicate and adapt our initial Pillow script
to use <a href=https://github.com/libvips/pyvips>PyVips</a>.</p><p>The watermarking operation is performed using a <a href="https://libvips.github.io/pyvips/vimage.html?highlight=composite#pyvips.Image.composite2"><code>pyvips.Image.composite2</code></a> method.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>source</span> <span class=o>=</span> <span class=n>pyvips</span><span class=o>.</span><span class=n>Image</span><span class=o>.</span><span class=n>new_from_file</span><span class=p>(</span><span class=n>SOURCE_IMAGE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>overlay</span> <span class=o>=</span> <span class=n>pyvips</span><span class=o>.</span><span class=n>Image</span><span class=o>.</span><span class=n>new_from_file</span><span class=p>(</span><span class=n>OVERLAY_IMAGE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>position_x</span><span class=p>,</span> <span class=n>position_y</span> <span class=o>=</span> <span class=p>(</span><span class=n>source</span><span class=o>.</span><span class=n>width</span> <span class=o>-</span> <span class=n>overlay</span><span class=o>.</span><span class=n>width</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=n>source</span><span class=o>.</span><span class=n>height</span> <span class=o>-</span> <span class=n>overlay</span><span class=o>.</span><span class=n>height</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># watermarking operation performed using composite2</span>
</span></span><span class=line><span class=cl><span class=n>watermarked</span> <span class=o>=</span> <span class=n>source</span><span class=o>.</span><span class=n>composite2</span><span class=p>(</span><span class=n>overlay</span><span class=p>,</span> <span class=s2>&#34;over&#34;</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=n>position_x</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=n>position_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>watermarked</span><span class=o>.</span><span class=n>write_to_file</span><span class=p>(</span><span class=n>RESULT_IMAGE</span><span class=p>)</span>
</span></span></code></pre></div><p>We can now run our performance evaluation command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> hyperfine <span class=s1>&#39;poetry run python3 example_pyvips/main.py&#39;</span>
</span></span><span class=line><span class=cl><span class=go>Benchmark 1: poetry run python3 example_pyvips/main.py
</span></span></span><span class=line><span class=cl><span class=go>  Time (mean ± σ):      1.330 s ±  0.044 s    [User: 2.792 s, System: 0.141 s]
</span></span></span><span class=line><span class=cl><span class=go>  Range (min … max):    1.277 s …  1.425 s    10 runs
</span></span></span></code></pre></div><p><em>1.33s? Odd.</em> Expecting the library to be blazing fast, let&rsquo;s keep this number in mind too.
Everything will make sense in a very short moment.</p><h3 id=dive-into-the-results>Dive into the results<a hidden class=anchor aria-hidden=true href=#dive-into-the-results>#</a></h3><p>By looking at <strong>script execution</strong> instead of <strong>operation duration</strong>, we also have unrelated processing
taking up some part of the duration. We have, for instance:</p><ul><li>Python interpreter startup time</li><li>I/O operations</li><li>Module import duration</li></ul><p>Something that we often don&rsquo;t see, especially when working on relatively small projects, is the potential
impact of the whole execution performed under-the-hood of some modules we used. Some projects, when imported,
will perform a set of actions such as bootstrapping dependencies, logging, &mldr;</p><p>A few years ago, the Instagram Engineering team wrote about the
concept of <a href=https://instagram-engineering.com/python-at-scale-strict-modules-c0bb9245c834>strict modules</a> that would guarantee the <strong>absence of side effects</strong>.
The concept in itself is great and can offer a lot of improvements, both for development and production
workloads.</p><p>By checking the duration of both import statements, we can already have a hint:</p><ul><li><code>import pillow</code>: <strong>0.069217s</strong></li><li><code>import pyvips</code>: <strong>0.172800s</strong></li></ul><p>Naturally, I ended up diving a bit in both project&rsquo;s (Pillow and PyVips) entrypoints and
without any surprise, we can observe that PyVips&rsquo; entrypoint
(<a href=https://github.com/libvips/pyvips/blob/master/pyvips/__init__.py><code>__init__.py</code></a>) is loading the LibVips bindings, configuring logging, &mldr; which can add up.</p><p>Considering that those values are not relevant for an actual long-lived service
(i.e.: ECS Service) or an execution with a Warmed up environment (i.e.: Lambdas), we
can safely dismiss those durations that correspond to &ldquo;cold starts&rdquo;.</p><p>If instead of observing the end-to-end processing, we only observe the actual
<strong>watermarking operation</strong> by extracting this specific code snippet
from our example code, we can have a much more accurate representation of a
realistic calculation.</p><p>We can achieve this by fiddling around with the <code>functools.partial</code> method
and the <code>timeit</code> module.</p><p>Our Pillow function now looks like the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>timeit</span>
</span></span><span class=line><span class=cl><span class=n>to_test</span> <span class=o>=</span> <span class=n>functools</span><span class=o>.</span><span class=n>partial</span><span class=p>(</span><span class=n>source</span><span class=o>.</span><span class=n>paste</span><span class=p>,</span> <span class=n>overlay</span><span class=p>,</span> <span class=p>(</span><span class=n>position_x</span><span class=p>,</span> <span class=n>position_y</span><span class=p>),</span> <span class=n>overlay</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>res</span> <span class=o>=</span> <span class=n>timeit</span><span class=o>.</span><span class=n>timeit</span><span class=p>(</span><span class=n>to_test</span><span class=p>,</span> <span class=n>number</span><span class=o>=</span><span class=mi>100000</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>res</span><span class=p>)</span>
</span></span></code></pre></div><p>And the PyVips function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>timeit</span>
</span></span><span class=line><span class=cl><span class=n>to_test</span> <span class=o>=</span> <span class=n>functools</span><span class=o>.</span><span class=n>partial</span><span class=p>(</span><span class=n>source</span><span class=o>.</span><span class=n>composite2</span><span class=p>,</span> <span class=n>overlay</span><span class=p>,</span> <span class=s2>&#34;over&#34;</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=n>position_x</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=n>position_y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>res</span> <span class=o>=</span> <span class=n>timeit</span><span class=o>.</span><span class=n>timeit</span><span class=p>(</span><span class=n>to_test</span><span class=p>,</span> <span class=n>number</span><span class=o>=</span><span class=mi>100000</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>res</span><span class=p>)</span>
</span></span></code></pre></div><p>We end up with the following summary table:</p><table><thead><tr><th>Library</th><th>100.000 watermarks</th><th>Import module</th><th>Single run duration</th></tr></thead><tbody><tr><td>Pillow</td><td>73.80s</td><td>00.046741s</td><td>1.10s</td></tr><tr><td>PyVips</td><td>8.09s</td><td>00.174187s</td><td>1.33s</td></tr></tbody></table><p>As we can see, the tiny overhead that we initially observed
with the single end to end script run timing is more than justified
on PyVips&rsquo; end.
By being nearly 10x faster to perform the same number operation, it&rsquo;s easy to
visualize the performance gains from using PyVips.</p><p>However, as stated in their <a href=https://github.com/libvips/libvips/wiki/Speed-and-memory-use#notes>&ldquo;Notes&rdquo;</a> section,
LibVips is by default shining on multi-core systems, which is what I&rsquo;m using.</p><h3 id=bonus-golang--libvips>Bonus: Golang + Libvips<a hidden class=anchor aria-hidden=true href=#bonus-golang--libvips>#</a></h3><p>As a bonus and for the sake of trying it out, I put together a simple
Go-based implementation. No surprise here, the whole program is going
faster than both end to end Python implementation and the language overhead
is slimmer than when using PyVips.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Load source and overlay images
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>source</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>vips</span><span class=p>.</span><span class=nf>NewImageFromFile</span><span class=p>(</span><span class=nx>SOURCE_IMAGE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;Failed to load source image: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nx>source</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>overlay</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>vips</span><span class=p>.</span><span class=nf>NewImageFromFile</span><span class=p>(</span><span class=nx>OVERLAY_IMAGE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;Failed to load overlay image: %v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nx>overlay</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Resize overlay if necessary (optional)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>overlayWidth</span> <span class=o>:=</span> <span class=nx>overlay</span><span class=p>.</span><span class=nf>Width</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>overlayHeight</span> <span class=o>:=</span> <span class=nx>overlay</span><span class=p>.</span><span class=nf>Height</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Calculate position to center overlay on source
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>x</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>source</span><span class=p>.</span><span class=nf>Width</span><span class=p>()</span> <span class=o>-</span> <span class=nx>overlayWidth</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nx>y</span> <span class=o>:=</span> <span class=p>(</span><span class=nx>source</span><span class=p>.</span><span class=nf>Height</span><span class=p>()</span> <span class=o>-</span> <span class=nx>overlayHeight</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Composite overlay onto the source image with transparency
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>err</span> <span class=p>=</span> <span class=nx>source</span><span class=p>.</span><span class=nf>Composite</span><span class=p>(</span><span class=nx>overlay</span><span class=p>,</span> <span class=nx>vips</span><span class=p>.</span><span class=nx>BlendModeOver</span><span class=p>,</span> <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>)</span>
</span></span></code></pre></div><p>We can then build and execute the <code>watermark-vips</code> binary:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> go build
</span></span><span class=line><span class=cl><span class=gp>$</span> hyperfine  watermark-vips
</span></span><span class=line><span class=cl><span class=go>Benchmark 1: watermark-vips
</span></span></span><span class=line><span class=cl><span class=go>  Time (mean ± σ):     292.2 ms ±  24.3 ms    [User: 281.3 ms, System: 72.1 ms]
</span></span></span><span class=line><span class=cl><span class=go>  Range (min … max):   252.6 ms … 321.3 ms    10 runs
</span></span></span></code></pre></div><p>Of course, this has much more implications as it&rsquo;s a completely different language, but it&rsquo;s
still great to know how much of a difference switching to Go could make in a specialized
micro-service approach.</p><h2 id=observations>Observations<a hidden class=anchor aria-hidden=true href=#observations>#</a></h2><p>It was quite fun to take the time to try out different patterns and to highlight the performance differences (here, speed mostly) of both libraries I&rsquo;ve been using for a while.</p><p>There is no right or wrong regarding library choice as Pillow still has plenty of usages, especially due to how easy it is to include in a project due to its &ldquo;completeness&rdquo; whereas PyVips&rsquo; plugin mechanism can sometimes include a &ldquo;compile it yourself&rdquo; step to support different file types.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The French Government developed <a href=https://filigrane.beta.gouv.fr/>filigrane.beta.gouv.fr</a>, which can be used to mitigate fraud and scams&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.tbobm.dev/tags/media-processing/>media processing</a></li><li><a href=https://blog.tbobm.dev/tags/performance/>performance</a></li><li><a href=https://blog.tbobm.dev/tags/python/>python</a></li><li><a href=https://blog.tbobm.dev/tags/go/>go</a></li><li><a href=https://blog.tbobm.dev/tags/tech/>tech</a></li></ul><nav class=paginav><a class=prev href=https://blog.tbobm.dev/posts/complete-health-checks/><span class=title>« Prev</span><br><span>Complete health checks and why they matter</span></a>
<a class=next href=https://blog.tbobm.dev/posts/row-level-database-tracking/><span class=title>Next »</span><br><span>Tracking Row Level changes in PostgreSQL</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.tbobm.dev>tbobm.dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>