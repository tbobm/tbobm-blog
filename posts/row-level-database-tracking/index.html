<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Tracking Row Level changes in PostgreSQL | tbobm</title><meta name=keywords content><meta name=description content="Automatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system. PostgreSQL exposes features that allow developers to automatically track changes at the row level, ensuring that every update is recorded with both a timestamp and an identifier of the application making the change.
In this post, I&rsquo;ll walk you through a method to implement automatic tracking of these changes using PostgreSQL triggers and functions."><meta name=author content="Theo &#34;Bob&#34; Massard"><link rel=canonical href=https://blog.tbobm.dev/posts/row-level-database-tracking/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.tbobm.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.tbobm.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.tbobm.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.tbobm.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.tbobm.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Tracking Row Level changes in PostgreSQL"><meta property="og:description" content="Automatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system. PostgreSQL exposes features that allow developers to automatically track changes at the row level, ensuring that every update is recorded with both a timestamp and an identifier of the application making the change.
In this post, I&rsquo;ll walk you through a method to implement automatic tracking of these changes using PostgreSQL triggers and functions."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.tbobm.dev/posts/row-level-database-tracking/"><meta property="og:image" content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-06T03:27:00+02:00"><meta property="article:modified_time" content="2024-09-06T03:27:00+02:00"><meta property="og:site_name" content="tbobm"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Tracking Row Level changes in PostgreSQL"><meta name=twitter:description content="Automatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system. PostgreSQL exposes features that allow developers to automatically track changes at the row level, ensuring that every update is recorded with both a timestamp and an identifier of the application making the change.
In this post, I&rsquo;ll walk you through a method to implement automatic tracking of these changes using PostgreSQL triggers and functions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.tbobm.dev/posts/"},{"@type":"ListItem","position":2,"name":"Tracking Row Level changes in PostgreSQL","item":"https://blog.tbobm.dev/posts/row-level-database-tracking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Tracking Row Level changes in PostgreSQL","name":"Tracking Row Level changes in PostgreSQL","description":"Automatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system. PostgreSQL exposes features that allow developers to automatically track changes at the row level, ensuring that every update is recorded with both a timestamp and an identifier of the application making the change.\nIn this post, I\u0026rsquo;ll walk you through a method to implement automatic tracking of these changes using PostgreSQL triggers and functions.","keywords":[],"articleBody":"Automatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system. PostgreSQL exposes features that allow developers to automatically track changes at the row level, ensuring that every update is recorded with both a timestamp and an identifier of the application making the change.\nIn this post, I’ll walk you through a method to implement automatic tracking of these changes using PostgreSQL triggers and functions.\nWhy Track Row-Level Changes? In any application where data integrity is critical—such as in document management systems, financial applications, or auditing systems—keeping a detailed history of changes can be essential. Knowing when a record was last updated and by whom helps in tracking issues, understanding user behavior, and maintaining compliance with data governance policies.\nPostgreSQL offers several mechanisms to track these changes automatically, ensuring that your application doesn’t miss a beat when it comes to recording who changed what and when.\nTracking the Last Update Author One common requirement is to track which user or application last updated a particular row in a table. PostgreSQL provides a neat way to do this using the current_setting function, combined with a trigger that updates the updated_by column whenever a row is modified.\nHere’s how you can implement this:\nStep 1: Create the Table We’ll start by creating a table called documents where each record represents a document with its content stored in JSON format. Additionally, we’ll include an updated_by column to store the identifier of the application or user that last modified the row.\nCREATE TABLE documents ( id INT PRIMARY KEY NOT NULL, content jsonb, updated_by text DEFAULT current_setting('application_name') ); Step 2: Create a Trigger Function Next, we’ll create a trigger function that will automatically update the updated_by column with the value of current_setting('application_name') whenever a row is updated. This function ensures that every modification to the document is attributed to the correct user or application.\nCREATE OR REPLACE FUNCTION set_last_update_author() RETURNS TRIGGER AS $$ BEGIN -- Set the updated_by column to the current client's application_name NEW.updated_by := current_setting('application_name'); RETURN NEW; END; $$ LANGUAGE plpgsql; Step 3: Attach the Trigger to the Table Finally, we attach the trigger function to the documents table. This trigger will fire before every update, ensuring that the updated_by column is always set correctly.\nCREATE TRIGGER update_app_name_trigger BEFORE UPDATE ON documents FOR EACH ROW EXECUTE FUNCTION set_last_update_author(); With this setup, every time a row in the documents table is updated, the updated_by field will automatically reflect the name of the application or user making the change.\nAutomatically Updating the Last Modified Timestamp In addition to tracking who made the change, it’s often necessary to track when the change was made. PostgreSQL makes this straightforward with the DEFAULT CURRENT_TIMESTAMP clause, which can be combined with ON UPDATE to ensure the timestamp is automatically updated whenever a row is modified.\nModify the Table Schema We can modify our documents table to include a last_updated column that automatically records the time of the last modification.\nALTER TABLE documents ADD COLUMN last_updated TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP; With this, the last_updated column will automatically update to the current timestamp whenever the row is updated, ensuring that you always know the precise time of the last change.\nConclusion By combining triggers, functions, and PostgreSQL’s built-in current_setting and CURRENT_TIMESTAMP features, you can create a robust system for automatically tracking row-level changes in your database. This setup requires minimal maintenance and ensures that your application can always provide accurate audit trails for data modifications.\nWhether you’re working on an internal tool or a production application, these techniques can help you maintain data integrity and transparency, making your system more reliable and trustworthy.\nFeel free to experiment with these concepts and adapt them to fit your specific needs. Happy coding!\n","wordCount":"635","inLanguage":"en","image":"https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-06T03:27:00+02:00","dateModified":"2024-09-06T03:27:00+02:00","author":{"@type":"Person","name":"Theo \"Bob\" Massard"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tbobm.dev/posts/row-level-database-tracking/"},"publisher":{"@type":"Organization","name":"tbobm","logo":{"@type":"ImageObject","url":"https://blog.tbobm.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.tbobm.dev accesskey=h title="tbobm (Alt + H)">tbobm</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.tbobm.dev/posts/now/ title=now><span>now</span></a></li><li><a href=https://blog.tbobm.dev/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.tbobm.dev>Home</a>&nbsp;»&nbsp;<a href=https://blog.tbobm.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Tracking Row Level changes in PostgreSQL</h1><div class=post-meta><span title='2024-09-06 03:27:00 +0200 +0200'>September 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;635 words&nbsp;·&nbsp;Theo "Bob" Massard&nbsp;|&nbsp;<a href=https://github.com/tbobm/tbobm-blog/content/posts/row-level-database-tracking.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=automatically-tracking-row-level-changes-in-postgresql>Automatically Tracking Row-Level Changes in PostgreSQL<a hidden class=anchor aria-hidden=true href=#automatically-tracking-row-level-changes-in-postgresql>#</a></h1><p>Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system.
PostgreSQL exposes features that allow developers to automatically track changes at the row level, ensuring that every update is recorded with both a timestamp and an identifier of the application making the change.</p><p>In this post, I&rsquo;ll walk you through a method to implement automatic tracking of these changes using PostgreSQL <a href=https://www.postgresql.org/docs/current/trigger-definition.html>triggers</a> and functions.</p><h2 id=why-track-row-level-changes>Why Track Row-Level Changes?<a hidden class=anchor aria-hidden=true href=#why-track-row-level-changes>#</a></h2><p>In any application where data integrity is critical—such as in document management systems, financial applications, or auditing systems—keeping a detailed history of changes can be essential. Knowing when a record was last updated and by whom helps in tracking issues, understanding user behavior, and maintaining compliance with data governance policies.</p><p>PostgreSQL offers several mechanisms to track these changes automatically, ensuring that your application doesn&rsquo;t miss a beat when it comes to recording who changed what and when.</p><h2 id=tracking-the-last-update-author>Tracking the Last Update Author<a hidden class=anchor aria-hidden=true href=#tracking-the-last-update-author>#</a></h2><p>One common requirement is to track which user or application last updated a particular row in a table. PostgreSQL provides a neat way to do this using the <code>current_setting</code> function, combined with a trigger that updates the <code>updated_by</code> column whenever a row is modified.</p><p>Here&rsquo;s how you can implement this:</p><h3 id=step-1-create-the-table>Step 1: Create the Table<a hidden class=anchor aria-hidden=true href=#step-1-create-the-table>#</a></h3><p>We&rsquo;ll start by creating a table called <code>documents</code> where each record represents a document with its content stored in JSON format. Additionally, we&rsquo;ll include an <code>updated_by</code> column to store the identifier of the application or user that last modified the row.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>documents</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>content</span><span class=w> </span><span class=n>jsonb</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>updated_by</span><span class=w> </span><span class=nb>text</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>current_setting</span><span class=p>(</span><span class=s1>&#39;application_name&#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h3 id=step-2-create-a-trigger-function>Step 2: Create a Trigger Function<a hidden class=anchor aria-hidden=true href=#step-2-create-a-trigger-function>#</a></h3><p>Next, we&rsquo;ll create a trigger function that will automatically update the <code>updated_by</code> column with the value of <code>current_setting('application_name')</code> whenever a row is updated. This function ensures that every modification to the document is attributed to the correct user or application.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>set_last_update_author</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>RETURNS</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- Set the updated_by column to the current client&#39;s application_name
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>NEW</span><span class=p>.</span><span class=n>updated_by</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=n>current_setting</span><span class=p>(</span><span class=s1>&#39;application_name&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>RETURN</span><span class=w> </span><span class=k>NEW</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>END</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=step-3-attach-the-trigger-to-the-table>Step 3: Attach the Trigger to the Table<a hidden class=anchor aria-hidden=true href=#step-3-attach-the-trigger-to-the-table>#</a></h3><p>Finally, we attach the trigger function to the <code>documents</code> table. This trigger will fire before every update, ensuring that the <code>updated_by</code> column is always set correctly.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=n>update_app_name_trigger</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEFORE</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>documents</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FOR</span><span class=w> </span><span class=k>EACH</span><span class=w> </span><span class=k>ROW</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXECUTE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>set_last_update_author</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>With this setup, every time a row in the <code>documents</code> table is updated, the <code>updated_by</code> field will automatically reflect the name of the application or user making the change.</p><h2 id=automatically-updating-the-last-modified-timestamp>Automatically Updating the Last Modified Timestamp<a hidden class=anchor aria-hidden=true href=#automatically-updating-the-last-modified-timestamp>#</a></h2><p>In addition to tracking who made the change, it&rsquo;s often necessary to track when the change was made. PostgreSQL makes this straightforward with the <code>DEFAULT CURRENT_TIMESTAMP</code> clause, which can be combined with <code>ON UPDATE</code> to ensure the timestamp is automatically updated whenever a row is modified.</p><h3 id=modify-the-table-schema>Modify the Table Schema<a hidden class=anchor aria-hidden=true href=#modify-the-table-schema>#</a></h3><p>We can modify our <code>documents</code> table to include a <code>last_updated</code> column that automatically records the time of the last modification.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>documents</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ADD</span><span class=w> </span><span class=k>COLUMN</span><span class=w> </span><span class=n>last_updated</span><span class=w> </span><span class=n>TIMESTAMPTZ</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>DEFAULT</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ON</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>With this, the <code>last_updated</code> column will automatically update to the current timestamp whenever the row is updated, ensuring that you always know the precise time of the last change.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>By combining triggers, functions, and PostgreSQL&rsquo;s built-in <code>current_setting</code> and <code>CURRENT_TIMESTAMP</code> features, you can create a robust system for automatically tracking row-level changes in your database. This setup requires minimal maintenance and ensures that your application can always provide accurate audit trails for data modifications.</p><p>Whether you&rsquo;re working on an internal tool or a production application, these techniques can help you maintain data integrity and transparency, making your system more reliable and trustworthy.</p><p>Feel free to experiment with these concepts and adapt them to fit your specific needs. Happy coding!</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://blog.tbobm.dev/posts/now/><span class=title>Next »</span><br><span>Now</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.tbobm.dev>tbobm</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>