<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Tracking Row Level changes in PostgreSQL | tbobm.dev</title><meta name=keywords content="postgresql,database,monitoring"><meta name=description content="Ownerships and modification dates often have a huge role in troubleshooting or understanding how applications work. Making last change metadata available can be a game changer in case of bug hunting or to understand how data behaves without digging through logs for hours.
Let&rsquo;s dive in a way of automating this &ldquo;last update&rdquo; tracking at the row level in Postgresql.
Code is available at github.com/tbobm/postgresql-row-level-changes
Automatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system."><meta name=author content="Theo &#34;Bob&#34; Massard"><link rel=canonical href=https://blog.tbobm.dev/posts/row-level-database-tracking/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.tbobm.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.tbobm.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.tbobm.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.tbobm.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.tbobm.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-TH8WFGGJBS"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TH8WFGGJBS",{anonymize_ip:!1})}</script><meta property="og:title" content="Tracking Row Level changes in PostgreSQL"><meta property="og:description" content="Ownerships and modification dates often have a huge role in troubleshooting or understanding how applications work. Making last change metadata available can be a game changer in case of bug hunting or to understand how data behaves without digging through logs for hours.
Let&rsquo;s dive in a way of automating this &ldquo;last update&rdquo; tracking at the row level in Postgresql.
Code is available at github.com/tbobm/postgresql-row-level-changes
Automatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.tbobm.dev/posts/row-level-database-tracking/"><meta property="og:image" content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-04T17:17:00+02:00"><meta property="article:modified_time" content="2024-11-04T17:17:00+02:00"><meta property="og:site_name" content="tbobm.dev"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Tracking Row Level changes in PostgreSQL"><meta name=twitter:description content="Ownerships and modification dates often have a huge role in troubleshooting or understanding how applications work. Making last change metadata available can be a game changer in case of bug hunting or to understand how data behaves without digging through logs for hours.
Let&rsquo;s dive in a way of automating this &ldquo;last update&rdquo; tracking at the row level in Postgresql.
Code is available at github.com/tbobm/postgresql-row-level-changes
Automatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.tbobm.dev/posts/"},{"@type":"ListItem","position":2,"name":"Tracking Row Level changes in PostgreSQL","item":"https://blog.tbobm.dev/posts/row-level-database-tracking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Tracking Row Level changes in PostgreSQL","name":"Tracking Row Level changes in PostgreSQL","description":"Ownerships and modification dates often have a huge role in troubleshooting or understanding how applications work. Making last change metadata available can be a game changer in case of bug hunting or to understand how data behaves without digging through logs for hours.\nLet\u0026rsquo;s dive in a way of automating this \u0026ldquo;last update\u0026rdquo; tracking at the row level in Postgresql.\nCode is available at github.com/tbobm/postgresql-row-level-changes\nAutomatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system.","keywords":["postgresql","database","monitoring"],"articleBody":"Ownerships and modification dates often have a huge role in troubleshooting or understanding how applications work. Making last change metadata available can be a game changer in case of bug hunting or to understand how data behaves without digging through logs for hours.\nLet’s dive in a way of automating this “last update” tracking at the row level in Postgresql.\nCode is available at github.com/tbobm/postgresql-row-level-changes\nAutomatically Tracking Row-Level Changes in PostgreSQL Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system. PostgreSQL exposes features that allow developers to automatically track changes at the row level, ensuring that every update is recorded with both a timestamp and an identifier of the application making the change.\nIn this post, I’ll walk you through a method to implement automatic tracking of these changes using PostgreSQL triggers and functions.\nWhy Track Row-Level Changes? In any application where data integrity is critical, understanding changes and who authored them can be essential to understand unexpected situations. Knowing when a record was last updated and by whom helps in tracking issues, understanding user behavior or how a system (mis)behaves.\nPostgreSQL offers several mechanisms to track these changes automatically, ensuring that your application doesn’t miss a beat when it comes to recording who changed what and when.\nThis requires very little overhead and can be progressively rolled out to multiple sub-components.\nTracking the Last Update Author One common requirement is to track which user or application last updated a particular row in a table. PostgreSQL provides a neat way to do this using the current_setting function, combined with a trigger that updates the updated_by column whenever a row is modified.\nLet’s see how to implement this behavior.\nCreate the Table We’ll start by creating a table called documents where each record represents a document with its content stored in JSON format. Additionally, we’ll include an updated_by column to store the identifier of the application or user that last modified the row.\nCREATE TABLE documents ( id INT PRIMARY KEY NOT NULL, content jsonb, updated_by text DEFAULT current_setting('application_name') ); The setting application_name can be set directly in Postgresql connection URIs by setting the ?application_name=my_app attribute suffix.\n$ psql postgresql://user:password@localhost/example?application_name=tbobm example=# select current_setting('application_name'); current_setting ----------------- tbobm Create a Trigger Function Next, we’ll create a trigger function that will automatically update the updated_by column with the value of current_setting('application_name') whenever a row is updated. This function ensures that every modification to the document is attributed to the correct user or application.\nCREATE OR REPLACE FUNCTION set_last_update_author() RETURNS TRIGGER AS $$ BEGIN -- Set the updated_by column to the current client's application_name NEW.updated_by := current_setting('application_name'); RETURN NEW; END; $$ LANGUAGE plpgsql; Attach the Trigger to the Table Finally, we attach the trigger function to the documents table. This trigger will fire before every update, ensuring that the updated_by column is always set correctly.\nCREATE TRIGGER update_app_name_trigger BEFORE UPDATE ON documents FOR EACH ROW EXECUTE FUNCTION set_last_update_author(); With this setup, every time a row in the documents table is updated, the updated_by field will automatically reflect the name of the application or user making the change.\nAutomatically Updating the Last Modified Timestamp In addition to tracking who made the change, it’s often necessary to track when the change was made. To ensure the last_updated column is updated on each row modification, we’ll use a default timestamp combined with a trigger function. This setup will automatically update the timestamp to the current time whenever a row is updated.\nThis requires 0 setup on the client side, which makes it very easy to add in an existing setup\nModify the Table Schema First, we’ll add the last_updated column to the documents table with a default value of the current timestamp (postgresql doc):\nALTER TABLE documents ADD COLUMN last_updated TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP; Create a Trigger Function Next, we create a trigger function to update the last_updated column to the current timestamp every time a row is modified:\nCREATE OR REPLACE FUNCTION update_last_updated_column() RETURNS TRIGGER AS $$ BEGIN NEW.last_updated := CURRENT_TIMESTAMP; RETURN NEW; END; $$ LANGUAGE plpgsql; Attach the Trigger to the Table Finally, we attach the trigger function to the documents table. This trigger will fire before every update, ensuring the last_updated column is set to the current time whenever a row is modified.\nCREATE TRIGGER set_last_updated BEFORE UPDATE ON documents FOR EACH ROW EXECUTE FUNCTION update_last_updated_column(); With this setup the last_updated column will automatically reflect the precise time (server side) of the latest change, providing a timestamp for each row modification.\nTesting our setup Let’s try out our freshly created automation on our documents table!\n-- Given a application_name=my_app URI client -- Insert a new document with content '{\"foo\": \"bar\"}' INSERT INTO documents (id, content) VALUES (1, '{\"foo\": \"bar\"}'); SELECT id, content, updated_by, last_updated from documents; -- | id | content | updated_by | last_updated | -- |----|-----------------|------------|----------------------------| -- | 1 | {\"foo\": \"bar\"} | my_app | | -- Update only the value of \"foo\" in the JSON content from \"bar\" to \"baz\" UPDATE documents SET content = jsonb_set(content, '{foo}', '\"baz\"') WHERE id = 1; SELECT id, content, updated_by, last_updated from documents; -- | id | content | updated_by | last_updated | -- |----|-----------------|------------|-----------------------------| -- | 1 | {\"foo\": \"baz\"} | my_app | | After the INSERT, the content is {\"foo\": \"bar\"}, updated_by is set to the application name (e.g., my_app), and last_updated records the timestamp at the moment of insertion. After the UPDATE, only the foo key in content has changed to \"baz\", and both updated_by and last_updated are updated to reflect the latest modification. Conclusion By combining triggers, functions, and PostgreSQL’s built-in current_setting and CURRENT_TIMESTAMP features, you can create a simple system for automatically tracking row-level changes in your database. This setup requires minimal maintenance and ensures that your application can always provide accurate audit trails for data modifications.\nWhether you’re working on an internal tool or a production application, these techniques can help you maintain data integrity and transparency, making your system more reliable and easy to understand.\nCheckout the minimal working setup here: postgresql-row-level-changes\nFeel free to reach out if you have feedbacks or questions !\nTheo “Bob” Massard\n","wordCount":"1028","inLanguage":"en","image":"https://blog.tbobm.dev/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-11-04T17:17:00+02:00","dateModified":"2024-11-04T17:17:00+02:00","author":{"@type":"Person","name":"Theo \"Bob\" Massard"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tbobm.dev/posts/row-level-database-tracking/"},"publisher":{"@type":"Organization","name":"tbobm.dev","logo":{"@type":"ImageObject","url":"https://blog.tbobm.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.tbobm.dev accesskey=h title="tbobm.dev (Alt + H)">tbobm.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.tbobm.dev/posts/now/ title=now><span>now</span></a></li><li><a href=https://blog.tbobm.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.tbobm.dev>Home</a>&nbsp;»&nbsp;<a href=https://blog.tbobm.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Tracking Row Level changes in PostgreSQL</h1><div class=post-meta><span title='2024-11-04 17:17:00 +0200 +0200'>November 4, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1028 words&nbsp;·&nbsp;Theo "Bob" Massard&nbsp;|&nbsp;<a href=https://github.com/tbobm/tbobm-blog/content/posts/row-level-database-tracking.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#why-track-row-level-changes>Why Track Row-Level Changes?</a></li><li><a href=#tracking-the-last-update-author>Tracking the Last Update Author</a><ul><li><a href=#create-the-table>Create the Table</a></li><li><a href=#create-a-trigger-function>Create a Trigger Function</a></li><li><a href=#attach-the-trigger-to-the-table>Attach the Trigger to the Table</a></li></ul></li><li><a href=#automatically-updating-the-last-modified-timestamp>Automatically Updating the Last Modified Timestamp</a><ul><li><a href=#modify-the-table-schema>Modify the Table Schema</a></li><li><a href=#create-a-trigger-function-1>Create a Trigger Function</a></li><li><a href=#attach-the-trigger-to-the-table-1>Attach the Trigger to the Table</a></li></ul></li><li><a href=#testing-our-setup>Testing our setup</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>Ownerships and modification dates often have a huge role in troubleshooting or understanding
how applications work. Making last change metadata available can be a game changer in case
of bug hunting or to understand how data behaves without digging through logs for hours.</p><p>Let&rsquo;s dive in a way of automating this &ldquo;last update&rdquo; tracking at the row level in Postgresql.</p><blockquote><p>Code is available at <a href=https://github.com/tbobm/postgresql-row-level-changes>github.com/tbobm/postgresql-row-level-changes</a></p></blockquote><h1 id=automatically-tracking-row-level-changes-in-postgresql>Automatically Tracking Row-Level Changes in PostgreSQL<a hidden class=anchor aria-hidden=true href=#automatically-tracking-row-level-changes-in-postgresql>#</a></h1><p>Managing changes to database records is a crucial part of maintaining data integrity and transparency in a system.
PostgreSQL exposes features that allow developers to automatically track changes at the row level,
ensuring that every update is recorded with both a timestamp and an identifier of the application making the change.</p><p>In this post, I&rsquo;ll walk you through a method to implement automatic tracking
of these changes using PostgreSQL <a href=https://www.postgresql.org/docs/current/trigger-definition.html>triggers</a> and functions.</p><h2 id=why-track-row-level-changes>Why Track Row-Level Changes?<a hidden class=anchor aria-hidden=true href=#why-track-row-level-changes>#</a></h2><p>In any application where data integrity is critical, understanding changes and who authored
them can be essential to understand unexpected situations.
Knowing when a record was last updated and by whom helps in tracking issues,
understanding user behavior or how a system (mis)behaves.</p><p>PostgreSQL offers several mechanisms to track these changes automatically,
ensuring that your application doesn&rsquo;t miss a beat when it comes to recording who changed what and when.</p><p>This requires very little overhead and can be progressively rolled out to multiple sub-components.</p><h2 id=tracking-the-last-update-author>Tracking the Last Update Author<a hidden class=anchor aria-hidden=true href=#tracking-the-last-update-author>#</a></h2><p>One common requirement is to track which user or application last updated a particular row in a table.
PostgreSQL provides a neat way to do this using the <a href=https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-SET><code>current_setting</code></a> function,
combined with a trigger that updates the <code>updated_by</code> column whenever a row is modified.</p><p>Let&rsquo;s see how to implement this behavior.</p><h3 id=create-the-table>Create the Table<a hidden class=anchor aria-hidden=true href=#create-the-table>#</a></h3><p>We&rsquo;ll start by creating a table called <code>documents</code> where each record represents a document with its
content stored in JSON format. Additionally, we&rsquo;ll include an <code>updated_by</code> column to store the
identifier of the application or user that last modified the row.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>documents</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>content</span><span class=w> </span><span class=n>jsonb</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>updated_by</span><span class=w> </span><span class=nb>text</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>current_setting</span><span class=p>(</span><span class=s1>&#39;application_name&#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>The setting <code>application_name</code> can be set directly in Postgresql connection URIs by setting
the <code>?application_name=my_app</code> attribute suffix.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=gp>$</span> psql postgresql://user:password@localhost/example?application_name<span class=o>=</span>tbobm
</span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=go>example=# select current_setting(&#39;application_name&#39;);
</span></span></span><span class=line><span class=cl><span class=go> current_setting 
</span></span></span><span class=line><span class=cl><span class=go>-----------------
</span></span></span><span class=line><span class=cl><span class=go> tbobm
</span></span></span></code></pre></div><h3 id=create-a-trigger-function>Create a Trigger Function<a hidden class=anchor aria-hidden=true href=#create-a-trigger-function>#</a></h3><p>Next, we&rsquo;ll create a trigger function that will automatically update the <code>updated_by</code> column with
the value of <code>current_setting('application_name')</code> whenever a row is updated. This function ensures
that every modification to the document is attributed to the correct user or application.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>set_last_update_author</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>RETURNS</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- Set the updated_by column to the current client&#39;s application_name
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>NEW</span><span class=p>.</span><span class=n>updated_by</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=n>current_setting</span><span class=p>(</span><span class=s1>&#39;application_name&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>RETURN</span><span class=w> </span><span class=k>NEW</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>END</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=attach-the-trigger-to-the-table>Attach the Trigger to the Table<a hidden class=anchor aria-hidden=true href=#attach-the-trigger-to-the-table>#</a></h3><p>Finally, we attach the trigger function to the <code>documents</code> table. This trigger will fire before
every update, ensuring that the <code>updated_by</code> column is always set correctly.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=n>update_app_name_trigger</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEFORE</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>documents</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FOR</span><span class=w> </span><span class=k>EACH</span><span class=w> </span><span class=k>ROW</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXECUTE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>set_last_update_author</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>With this setup, every time a row in the <code>documents</code> table is updated, the <code>updated_by</code> field
will automatically reflect the name of the application or user making the change.</p><h2 id=automatically-updating-the-last-modified-timestamp>Automatically Updating the Last Modified Timestamp<a hidden class=anchor aria-hidden=true href=#automatically-updating-the-last-modified-timestamp>#</a></h2><p>In addition to tracking <strong>who</strong> made the change, it&rsquo;s often necessary to track when the change was made.
To ensure the <code>last_updated</code> column is updated on each row modification, we&rsquo;ll use a default
timestamp combined with a trigger function. This setup will automatically update the timestamp
to the current time whenever a row is updated.</p><blockquote><p>This requires 0 setup on the client side, which makes it very easy to add in an existing setup</p></blockquote><h3 id=modify-the-table-schema>Modify the Table Schema<a hidden class=anchor aria-hidden=true href=#modify-the-table-schema>#</a></h3><p>First, we’ll add the <code>last_updated</code> column to the <code>documents</code> table with a default
value of the current timestamp (<a href=https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT>postgresql doc</a>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>documents</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ADD</span><span class=w> </span><span class=k>COLUMN</span><span class=w> </span><span class=n>last_updated</span><span class=w> </span><span class=n>TIMESTAMPTZ</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=create-a-trigger-function-1>Create a Trigger Function<a hidden class=anchor aria-hidden=true href=#create-a-trigger-function-1>#</a></h3><p>Next, we create a trigger function to update the <code>last_updated</code> column to the current timestamp every time a row is modified:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>update_last_updated_column</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>RETURNS</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>NEW</span><span class=p>.</span><span class=n>last_updated</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>RETURN</span><span class=w> </span><span class=k>NEW</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>END</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=attach-the-trigger-to-the-table-1>Attach the Trigger to the Table<a hidden class=anchor aria-hidden=true href=#attach-the-trigger-to-the-table-1>#</a></h3><p>Finally, we attach the trigger function to the <code>documents</code> table. This trigger will fire before
every update, ensuring the <code>last_updated</code> column is set to the current time whenever a row is modified.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=n>set_last_updated</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEFORE</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>documents</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FOR</span><span class=w> </span><span class=k>EACH</span><span class=w> </span><span class=k>ROW</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>EXECUTE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>update_last_updated_column</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>With this setup the <code>last_updated</code> column will automatically reflect the precise
time (server side) of the latest change, providing a timestamp for each row modification.</p><h2 id=testing-our-setup>Testing our setup<a hidden class=anchor aria-hidden=true href=#testing-our-setup>#</a></h2><p>Let&rsquo;s try out our freshly created automation on our <code>documents</code> table!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- Given a application_name=my_app URI client
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Insert a new document with content &#39;{&#34;foo&#34;: &#34;bar&#34;}&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>documents</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>content</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;{&#34;foo&#34;: &#34;bar&#34;}&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=n>updated_by</span><span class=p>,</span><span class=w> </span><span class=n>last_updated</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>documents</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- | id |     content     | updated_by |       last_updated         |
</span></span></span><span class=line><span class=cl><span class=c1>-- |----|-----------------|------------|----------------------------|
</span></span></span><span class=line><span class=cl><span class=c1>-- |  1 | {&#34;foo&#34;: &#34;bar&#34;}  | my_app     | &lt;current_timestamp&gt;        |
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Update only the value of &#34;foo&#34; in the JSON content from &#34;bar&#34; to &#34;baz&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>documents</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SET</span><span class=w> </span><span class=n>content</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>jsonb_set</span><span class=p>(</span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;{foo}&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;&#34;baz&#34;&#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>content</span><span class=p>,</span><span class=w> </span><span class=n>updated_by</span><span class=p>,</span><span class=w> </span><span class=n>last_updated</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>documents</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- | id |     content     | updated_by |         last_updated        |
</span></span></span><span class=line><span class=cl><span class=c1>-- |----|-----------------|------------|-----------------------------|
</span></span></span><span class=line><span class=cl><span class=c1>-- |  1 | {&#34;foo&#34;: &#34;baz&#34;}  | my_app     | &lt;updated_current_timestamp&gt; |
</span></span></span></code></pre></div><ul><li>After the <code>INSERT</code>, the <code>content</code> is <code>{"foo": "bar"}</code>, <code>updated_by</code> is set to the application name (e.g., <code>my_app</code>), and <code>last_updated</code> records the timestamp at the moment of insertion.</li><li>After the <code>UPDATE</code>, only the <code>foo</code> key in <code>content</code> has changed to <code>"baz"</code>, and both <code>updated_by</code> and <code>last_updated</code> are updated to reflect the latest modification.</li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>By combining triggers, functions, and PostgreSQL&rsquo;s built-in <a href=https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-SET><code>current_setting</code></a>
and <a href=https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT><code>CURRENT_TIMESTAMP</code></a> features, you can create a simple system for
automatically tracking row-level changes in your database. This setup requires minimal maintenance
and ensures that your application can always provide accurate audit trails for data modifications.</p><p>Whether you&rsquo;re working on an internal tool or a production application, these techniques
can help you maintain data integrity and transparency, making your system more reliable and easy to understand.</p><p>Checkout the minimal working setup here: <a href=https://github.com/tbobm/postgresql-row-level-changes>postgresql-row-level-changes</a></p><p>Feel free to reach out if you have feedbacks or questions !</p><p><a href=https://linkedin.com/in/tbobm/>Theo &ldquo;Bob&rdquo; Massard</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.tbobm.dev/tags/postgresql/>postgresql</a></li><li><a href=https://blog.tbobm.dev/tags/database/>database</a></li><li><a href=https://blog.tbobm.dev/tags/monitoring/>monitoring</a></li></ul><nav class=paginav><a class=next href=https://blog.tbobm.dev/posts/now/><span class=title>Next »</span><br><span>Now</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.tbobm.dev>tbobm.dev</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>